package runtime

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/google/jsonschema-go/jsonschema"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// MustParseSchema parses a JSON string into a *jsonschema.Schema.
// Panics on failure â€” intended for use in package-level var blocks with
// static JSON generated by protoc-gen-go-mcp.
func MustParseSchema(raw string) *jsonschema.Schema {
	var s jsonschema.Schema
	if err := json.Unmarshal([]byte(raw), &s); err != nil {
		panic(fmt.Sprintf("runtime: failed to parse JSON schema: %v", err))
	}
	return &s
}

// MustCreateTool builds an *mcp.Tool from a name, description, and raw JSON schema.
// Panics if the schema cannot be parsed.
func MustCreateTool(name, description, schemaJSON string) *mcp.Tool {
	return &mcp.Tool{
		Name:        name,
		Description: description,
		InputSchema: MustParseSchema(schemaJSON),
	}
}

// PrepareToolWithExtras returns a shallow clone of tool with extra properties
// injected into its InputSchema.  If there are no extras the original tool is
// returned as-is.
func PrepareToolWithExtras(tool *mcp.Tool, extras []ExtraProperty) *mcp.Tool {
	if len(extras) == 0 {
		return tool
	}

	original, ok := tool.InputSchema.(*jsonschema.Schema)
	if !ok {
		return tool
	}

	schema := original.CloneSchemas()
	if schema.Properties == nil {
		schema.Properties = make(map[string]*jsonschema.Schema)
	}

	for _, prop := range extras {
		schema.Properties[prop.Name] = &jsonschema.Schema{
			Type:        "string",
			Description: prop.Description,
		}
		if prop.Required {
			schema.Required = append(schema.Required, prop.Name)
		}
	}

	cloned := *tool
	cloned.InputSchema = schema
	return &cloned
}

// TextResult creates a CallToolResult containing a single text content block.
// Use for successful tool responses:
//
//	return runtime.TextResult(string(jsonBytes)), nil
func TextResult(text string) *mcp.CallToolResult {
	return &mcp.CallToolResult{
		Content: []mcp.Content{&mcp.TextContent{Text: text}},
	}
}

// ErrorResult creates a CallToolResult flagged as an error.
// Prefer HandleError for gRPC errors; use ErrorResult for custom error messages.
func ErrorResult(text string) *mcp.CallToolResult {
	return &mcp.CallToolResult{
		Content: []mcp.Content{&mcp.TextContent{Text: text}},
		IsError: true,
	}
}

// ExtractExtras unmarshals raw JSON arguments, pulls out any configured extra
// properties into the context, and returns the (potentially modified) arguments
// as a byte slice ready for protojson.Unmarshal.
//
// When no extra properties are configured the raw bytes are returned unchanged.
func ExtractExtras(ctx context.Context, raw json.RawMessage, cfg *Config) (json.RawMessage, context.Context) {
	if len(cfg.ExtraProperties) == 0 {
		return raw, ctx
	}

	var m map[string]any
	if err := json.Unmarshal(raw, &m); err != nil {
		return raw, ctx
	}

	for _, prop := range cfg.ExtraProperties {
		if v, ok := m[prop.Name]; ok {
			ctx = context.WithValue(ctx, prop.ContextKey, v)
		}
	}

	// Re-marshal in case the caller wants the extras stripped later.
	out, err := json.Marshal(m)
	if err != nil {
		return raw, ctx
	}
	return out, ctx
}
