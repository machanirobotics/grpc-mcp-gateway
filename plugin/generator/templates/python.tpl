# Code generated by protoc-gen-mcp. DO NOT EDIT.
# versions:
# 	protoc-gen-mcp {{ .Version }}
# Authors: Machani Robotics - Open Source 2026
# source: {{ .SourcePath }}

from __future__ import annotations

import json
from typing import Any, Protocol

import mcp.types as types
from mcp.server.fastmcp import FastMCP
from mcp.server.lowlevel import Server
from google.protobuf.json_format import MessageToDict, ParseDict

{{ .PBImports }}

{{- range $key, $val := .SchemaJSON }}
{{ $key }}_SCHEMA = json.loads(r'''{{ $val }}''')
{{- end }}

{{ range $key, $val := .SchemaJSON }}
{{ $key }}_TOOL = types.Tool(
    name="{{ (index $.ToolMeta $key).Name }}",
    description={{ (index $.ToolMeta $key).Description | pyString }},
    inputSchema={{ $key }}_SCHEMA,
)
{{ end }}

{{- range $svcName, $methods := .Services }}

class {{ $svcName }}MCPServer(Protocol):
    """Protocol that users implement to handle MCP tool calls backed by {{ $svcName }} RPCs."""
{{- range $methName, $tool := $methods }}
    async def {{ $tool.PyMethodName }}(self, request: {{ $tool.PyRequestType }}) -> {{ $tool.PyResponseType }}: ...
{{- end }}

class {{ $svcName }}MCPClient(Protocol):
    """gRPC client protocol used when forwarding MCP tool calls to a remote server."""
{{- range $methName, $tool := $methods }}
    async def {{ $tool.PyMethodName }}(self, request: {{ $tool.PyRequestType }}) -> {{ $tool.PyResponseType }}: ...
{{- end }}
{{- end }}

{{- range $svcName, $methods := .Services }}

{{ $svcName }}_MCP_DEFAULT_BASE_PATH = "{{ index $.ServiceBasePaths $svcName }}"
{{- end }}

_ALL_TOOLS: list[types.Tool] = [
{{- range $key, $val := .SchemaJSON }}
    {{ $key }}_TOOL,
{{- end }}
]

{{- range $svcName, $methods := .Services }}
{{- $svcOpts := index $.ServiceOpts $svcName }}

def _{{ $svcName | snakeCase }}_prompts() -> list[types.Prompt]:
    """Build the list of prompt descriptors for {{ $svcName }}."""
    return [
{{- range $methName, $tool := $methods }}
{{- if and $tool.MethodOpts $tool.MethodOpts.Prompt }}
        types.Prompt(
            name="{{ $tool.MethodOpts.Prompt.Name }}",
            description="{{ escapeQuotes $tool.MethodOpts.Prompt.Description }}",
            arguments=[
            {{- range $tool.MethodOpts.Prompt.Arguments }}
                types.PromptArgument(name="{{ .Name }}", description="{{ escapeQuotes .Description }}", required={{ if .Required }}True{{ else }}False{{ end }}),
            {{- end }}
            ],
        ),
{{- end }}
{{- end }}
    ]

def _{{ $svcName | snakeCase }}_resources() -> list[types.Resource | types.ResourceTemplate]:
    """Build the list of resource descriptors for {{ $svcName }}."""
    return [
{{- if and $svcOpts $svcOpts.Resources }}
{{- range $svcOpts.Resources }}
{{- if .URI }}
        types.Resource(uri="{{ .URI }}", name="{{ .Name }}", description="{{ escapeQuotes .Description }}", mimeType="{{ .MimeType }}"),
{{- end }}
{{- if .URITemplate }}
        types.ResourceTemplate(uriTemplate="{{ .URITemplate }}", name="{{ .Name }}", description="{{ escapeQuotes .Description }}", mimeType="{{ .MimeType }}"),
{{- end }}
{{- end }}
{{- end }}
    ]

def _{{ $svcName | snakeCase }}_completion_map() -> dict[str, list[str]]:
    """Build a map of 'promptName:argName' -> allowed values from enum_values."""
    m: dict[str, list[str]] = {}
{{- range $methName, $tool := $methods }}
{{- if and $tool.MethodOpts $tool.MethodOpts.Prompt }}
{{- $pName := $tool.MethodOpts.Prompt.Name }}
{{- range $tool.MethodOpts.Prompt.Arguments }}
{{- if .EnumValues }}
    m["{{ $pName }}:{{ .Name }}"] = [{{ range .EnumValues }}"{{ . }}", {{ end }}]
{{- end }}
{{- end }}
{{- end }}
{{- end }}
    return m

def register_{{ $svcName | snakeCase }}_mcp_handler(server: Server, impl: {{ $svcName }}MCPServer) -> None:
    """Register all {{ $svcName }} tools, prompts, and resources on the given MCP server."""

    @server.list_tools()
    async def handle_list_tools() -> list[types.Tool]:
        return _ALL_TOOLS

    @server.call_tool()
    async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[types.TextContent]:
{{- range $methName, $tool := $methods }}
        if name == "{{ $tool.ToolName }}":
{{- if and $tool.MethodOpts $tool.MethodOpts.Elicitation }}
            try:
                _elicit_result = await server.request_context.session.elicit(
                    message={{ $tool.MethodOpts.Elicitation.Message | pyString }},
                    requestedSchema={
                        "type": "object",
                        "properties": {
                        {{- range $tool.MethodOpts.Elicitation.Fields }}
                            "{{ .Name }}": {"type": "{{ .Type }}", "description": "{{ escapeQuotes .Description }}"{{ if .EnumValues }}, "enum": [{{ range .EnumValues }}"{{ . }}", {{ end }}]{{ end }}},
                        {{- end }}
                        },
                        "required": [{{ range $tool.MethodOpts.Elicitation.Fields }}{{ if .Required }}"{{ .Name }}", {{ end }}{{ end }}],
                    },
                )
                if _elicit_result.action != "accept":
                    return [types.TextContent(type="text", text="Action cancelled by user.")]
            except Exception:
                pass  # Client does not support elicitation; proceed with tool call.
{{- end }}
            req = ParseDict(arguments, {{ $tool.PyRequestType }}())
            resp = await impl.{{ $tool.PyMethodName }}(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
{{- end }}
        raise ValueError(f"Unknown tool: {name}")

    _prompts = _{{ $svcName | snakeCase }}_prompts()
    if _prompts:
        @server.list_prompts()
        async def handle_list_prompts() -> list[types.Prompt]:
            return _prompts

        @server.get_prompt()
        async def handle_get_prompt(name: str, arguments: dict[str, str] | None) -> types.GetPromptResult:
            for p in _prompts:
                if p.name == name:
                    arg_str = ", ".join(f"{k}={v}" for k, v in (arguments or {}).items())
                    return types.GetPromptResult(
                        description=p.description,
                        messages=[types.PromptMessage(role="user", content=types.TextContent(type="text", text=f"{p.description} ({arg_str})"))],
                    )
            raise ValueError(f"Unknown prompt: {name}")

    _resources = _{{ $svcName | snakeCase }}_resources()
    if _resources:
        @server.list_resources()
        async def handle_list_resources() -> list[types.Resource]:
            return [r for r in _resources if isinstance(r, types.Resource)]

        @server.read_resource()
        async def handle_read_resource(uri: str) -> str:
            return "{}"
{{- end }}

{{- range $svcName, $methods := .Services }}

def serve_{{ $svcName | snakeCase }}_mcp(
    impl: {{ $svcName }}MCPServer,
    *,
    transport: str = "streamable-http",
    host: str = "0.0.0.0",
    port: int = 8080,
    path: str | None = None,
) -> None:
    """Create a FastMCP server, register {{ $svcName }} tools, and start serving."""
    import contextlib, threading  # noqa: E401
    if path is None:
        path = {{ $svcName }}_MCP_DEFAULT_BASE_PATH

    transports = [t.strip() for t in transport.split(",") if t.strip()]
    has_stdio = "stdio" in transports
    http_transports = [t for t in transports if t in ("sse", "streamable-http")]

    mcp_server = FastMCP("{{ $svcName }}", json_response=True, streamable_http_path="/")
    register_{{ $svcName | snakeCase }}_mcp_handler(mcp_server._mcp_server, impl)

    @contextlib.asynccontextmanager
    async def _lifespan(app):
        async with mcp_server.session_manager.run():
            yield

    if http_transports and has_stdio:
        def _run_http() -> None:
            import uvicorn
            from starlette.applications import Starlette
            from starlette.routing import Mount
            ht = http_transports[0]
            mcp_app = mcp_server.sse_app() if ht == "sse" else mcp_server.streamable_http_app()
            app = Starlette(routes=[Mount(path, app=mcp_app)], lifespan=_lifespan)
            cfg = uvicorn.Config(app, host=host, port=port, timeout_graceful_shutdown=0)
            uvicorn.Server(cfg).run()
        threading.Thread(target=_run_http, daemon=True).start()
        mcp_server.run(transport="stdio")
    elif http_transports:
        import uvicorn
        from starlette.applications import Starlette
        from starlette.routing import Mount, Route
        routes: list[Mount | Route] = []
        for ht in http_transports:
            mcp_app = mcp_server.sse_app() if ht == "sse" else mcp_server.streamable_http_app()
            routes.append(Mount(path if ht != "sse" else path, app=mcp_app))
        app = Starlette(routes=routes, lifespan=_lifespan)
        cfg = uvicorn.Config(app, host=host, port=port, timeout_graceful_shutdown=0)
        uvicorn.Server(cfg).run()
    elif has_stdio:
        mcp_server.run(transport="stdio")
    else:
        raise ValueError(f"Unsupported transport(s): {transport}")
{{- end }}

{{- range $svcName, $methods := .Services }}

def forward_to_{{ $svcName | snakeCase }}_mcp_client(server: Server, client: {{ $svcName }}MCPClient) -> None:
    """Register all {{ $svcName }} tools on the MCP server, forwarding each call to a remote gRPC server."""

    @server.list_tools()
    async def handle_list_tools() -> list[types.Tool]:
        return _ALL_TOOLS

    @server.call_tool()
    async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[types.TextContent]:
{{- range $methName, $tool := $methods }}
        if name == "{{ $tool.ToolName }}":
{{- if and $tool.MethodOpts $tool.MethodOpts.Elicitation }}
            try:
                _elicit_result = await server.request_context.session.elicit(
                    message={{ $tool.MethodOpts.Elicitation.Message | pyString }},
                    requestedSchema={
                        "type": "object",
                        "properties": {
                        {{- range $tool.MethodOpts.Elicitation.Fields }}
                            "{{ .Name }}": {"type": "{{ .Type }}", "description": "{{ escapeQuotes .Description }}"{{ if .EnumValues }}, "enum": [{{ range .EnumValues }}"{{ . }}", {{ end }}]{{ end }}},
                        {{- end }}
                        },
                        "required": [{{ range $tool.MethodOpts.Elicitation.Fields }}{{ if .Required }}"{{ .Name }}", {{ end }}{{ end }}],
                    },
                )
                if _elicit_result.action != "accept":
                    return [types.TextContent(type="text", text="Action cancelled by user.")]
            except Exception:
                pass  # Client does not support elicitation; proceed with tool call.
{{- end }}
            req = ParseDict(arguments, {{ $tool.PyRequestType }}())
            resp = await client.{{ $tool.PyMethodName }}(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
{{- end }}
        raise ValueError(f"Unknown tool: {name}")
{{- end }}
