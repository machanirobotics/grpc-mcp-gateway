// Code generated by protoc-gen-mcp. DO NOT EDIT.
// versions:
// 	protoc-gen-mcp {{ .Version }}
// Authors: Machani Robotics - Open Source 2026
// source: {{ .SourcePath }}

use std::sync::Arc;
use rmcp::{ErrorData as McpError, RoleServer, ServerHandler, ServiceExt, model::*, service::RequestContext};
use serde_json::{self, json, Value};

fn make_tool(name: &str, description: &str, schema_json: &str) -> Tool {
    serde_json::from_value(json!({
        "name": name, "description": description,
        "inputSchema": serde_json::from_str::<Value>(schema_json).unwrap(),
    })).expect("generated tool schema must be valid")
}
{{ range $svcName, $methods := .Services }}
{{- range $methName, $info := $methods }}
const {{ $info.ConstName }}_SCHEMA_JSON: &str = r##"{{ index $.SchemaJSON (printf "%s_%s" $svcName $methName) }}"##;
{{- end }}

pub struct {{ $svcName }}McpHandler {
    inner: cxx::UniquePtr<crate::ffi_{{ $svcName | snakeCase }}::{{ $svcName }}McpImpl>,
}

unsafe impl Send for {{ $svcName }}McpHandler {}
unsafe impl Sync for {{ $svcName }}McpHandler {}

impl {{ $svcName }}McpHandler {
    pub fn new() -> Self {
        Self { inner: crate::ffi_{{ $svcName | snakeCase }}::new_{{ $svcName | snakeCase }}_mcp() }
    }

    fn tools() -> Vec<Tool> {
        vec![
        {{- range $methName, $info := $methods }}
            make_tool("{{ $info.ToolName }}", "{{ $info.Description | rsEscape }}", {{ $info.ConstName }}_SCHEMA_JSON),
        {{- end }}
        ]
    }
}

impl Clone for {{ $svcName }}McpHandler {
    fn clone(&self) -> Self { Self::new() }
}

impl ServerHandler for {{ $svcName }}McpHandler {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            capabilities: ServerCapabilities::builder()
                .enable_tools()
                .build(),
            server_info: Implementation { name: "{{ $svcName }}".into(), version: "0.1.0".into(), ..Default::default() },
            ..Default::default()
        }
    }

    async fn list_tools(&self, _: Option<PaginatedRequestParams>, _: RequestContext<RoleServer>) -> Result<ListToolsResult, McpError> {
        Ok(ListToolsResult::with_all_items(Self::tools()))
    }

    async fn call_tool(&self, request: CallToolRequestParams, _: RequestContext<RoleServer>) -> Result<CallToolResult, McpError> {
        let args = request.arguments.map_or_else(|| Value::Object(Default::default()), Value::Object);
        let args_json = serde_json::to_string(&args)
            .map_err(|e| McpError::internal_error(format!("serialize args: {e}"), None))?;
        let result_json = match request.name.as_ref() {
        {{- range $methName, $info := $methods }}
            "{{ $info.ToolName }}" => self.inner.{{ $info.CppMethodName }}(&args_json),
        {{- end }}
            _ => return Err(McpError::internal_error(format!("unknown tool: {}", request.name), None)),
        };
        Ok(CallToolResult::success(vec![Content::text(result_json)]))
    }
}

pub const {{ $svcName | screamingSnakeCase }}_MCP_DEFAULT_BASE_PATH: &str = "{{ index $.ServiceBasePaths $svcName }}";

pub async fn serve_{{ $svcName | snakeCase }}_mcp_stdio() -> Result<(), Box<dyn std::error::Error>> {
    let handler = {{ $svcName }}McpHandler::new();
    handler.serve(rmcp::transport::stdio()).await?.waiting().await?;
    Ok(())
}

pub async fn serve_{{ $svcName | snakeCase }}_mcp(
    host: &str, port: u16, base_path: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let handler = {{ $svcName }}McpHandler::new();
    use rmcp::transport::streamable_http_server::{
        StreamableHttpServerConfig, StreamableHttpService, session::local::LocalSessionManager,
    };
    let config = StreamableHttpServerConfig::default();
    let h = handler.clone();
    let service = StreamableHttpService::new(
        move || Ok(h.clone()), Arc::new(LocalSessionManager::default()), config,
    );
    let app = axum::Router::new().nest_service(base_path, service);
    let addr = format!("{host}:{port}");
    let listener = tokio::net::TcpListener::bind(&addr).await?;
    eprintln!("MCP server listening on {addr}{base_path}");
    axum::serve(listener, app).await?;
    Ok(())
}
{{ end }}
