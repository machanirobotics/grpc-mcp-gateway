// Code generated by protoc-gen-mcp. DO NOT EDIT.
// versions:
// 	protoc-gen-mcp {{ .Version }}
// Authors: Machani Robotics - Open Source 2026
// source: {{ .SourcePath }}

use std::sync::Arc;
use async_trait::async_trait;
use tokio_stream::StreamExt;
use rmcp::{ErrorData as McpError, RoleServer, ServerHandler, ServiceExt, model::*, service::RequestContext};
use serde_json::{self, json, Value};

fn make_tool(name: &str, description: &str, schema_json: &str) -> Tool {
    serde_json::from_value(json!({
        "name": name, "description": description,
        "inputSchema": serde_json::from_str::<Value>(schema_json).unwrap(),
    })).expect("generated tool schema must be valid")
}
{{ range $svcName, $methods := .Services }}
{{- $svcOpts := index $.ServiceOpts $svcName }}
{{- range $methName, $info := $methods }}
const {{ $info.ConstName }}_SCHEMA_JSON: &str = r##"{{ index $.SchemaJSON (printf "%s_%s" $svcName $methName) }}"##;
{{- end }}

#[async_trait]
pub trait {{ $svcName }}McpServer: Send + Sync + 'static {
{{- range $methName, $info := $methods }}
{{- if not $info.StreamProgress }}
    async fn {{ $info.RsMethodName }}(&self, args: Value) -> Result<Value, McpError>;
{{- end }}
{{- end }}
}

pub struct {{ $svcName }}McpHandler<T: {{ $svcName }}McpServer> { inner: Arc<T> }

impl<T: {{ $svcName }}McpServer> Clone for {{ $svcName }}McpHandler<T> {
    fn clone(&self) -> Self { Self { inner: Arc::clone(&self.inner) } }
}

impl<T: {{ $svcName }}McpServer> {{ $svcName }}McpHandler<T> {
    pub fn new(svc: T) -> Self { Self { inner: Arc::new(svc) } }

    fn tools() -> Vec<Tool> {
        vec![
        {{- range $methName, $info := $methods }}
        {{- if not $info.StreamProgress }}
            make_tool("{{ $info.ToolName }}", "{{ $info.Description | rsEscape }}", {{ $info.ConstName }}_SCHEMA_JSON),
        {{- end }}
        {{- end }}
        ]
    }

    fn all_tools() -> Vec<Tool> {
        vec![
        {{- range $methName, $info := $methods }}
            make_tool("{{ $info.ToolName }}", "{{ $info.Description | rsEscape }}", {{ $info.ConstName }}_SCHEMA_JSON),
        {{- end }}
        ]
    }
{{- $hasPrompts := false }}
{{- range $methName, $info := $methods }}
{{- if and $info.MethodOpts $info.MethodOpts.Prompt }}{{ $hasPrompts = true }}{{ end }}
{{- end }}
{{- if $hasPrompts }}

    fn prompts() -> Vec<Prompt> {
        vec![
        {{- range $methName, $info := $methods }}
        {{- if and $info.MethodOpts $info.MethodOpts.Prompt }}
            serde_json::from_value(json!({
                "name": "{{ $info.MethodOpts.Prompt.Name }}",
                "description": "{{ $info.MethodOpts.Prompt.Description | rsEscape }}",
                "arguments": [
                {{- range $info.MethodOpts.Prompt.Arguments }}
                    {"name": "{{ .Name }}", "description": "{{ .Description | rsEscape }}", "required": {{ if .Required }}true{{ else }}false{{ end }}},
                {{- end }}
                ]
            })).expect("generated prompt must be valid"),
        {{- end }}
        {{- end }}
        ]
    }
{{- end }}
{{- if and $svcOpts $svcOpts.Resources }}

    fn resources() -> Vec<Resource> {
        vec![
        {{- range $svcOpts.Resources }}
        {{- if .URI }}
            serde_json::from_value(json!({
                "uri": "{{ .URI }}", "name": "{{ .Name }}",
                "description": "{{ .Description | rsEscape }}", "mimeType": "{{ .MimeType }}"
            })).expect("generated resource must be valid"),
        {{- end }}
        {{- end }}
        ]
    }

    fn resource_templates() -> Vec<ResourceTemplate> {
        vec![
        {{- range $svcOpts.Resources }}
        {{- if .URITemplate }}
            serde_json::from_value(json!({
                "uriTemplate": "{{ .URITemplate }}", "name": "{{ .Name }}",
                "description": "{{ .Description | rsEscape }}", "mimeType": "{{ .MimeType }}"
            })).expect("generated resource template must be valid"),
        {{- end }}
        {{- end }}
        ]
    }
{{- end }}
}

impl<T: {{ $svcName }}McpServer> ServerHandler for {{ $svcName }}McpHandler<T> {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            capabilities: ServerCapabilities::builder()
                .enable_tools()
{{- if $hasPrompts }}
                .enable_prompts()
{{- end }}
{{- if and $svcOpts $svcOpts.Resources }}
                .enable_resources()
{{- end }}
                .build(),
            server_info: Implementation { name: "{{ $svcName }}".into(), version: "0.1.0".into(), ..Default::default() },
            ..Default::default()
        }
    }

    async fn list_tools(&self, _: Option<PaginatedRequestParams>, _: RequestContext<RoleServer>) -> Result<ListToolsResult, McpError> {
        Ok(ListToolsResult::with_all_items(Self::tools()))
    }

    async fn call_tool(&self, request: CallToolRequestParams, context: RequestContext<RoleServer>) -> Result<CallToolResult, McpError> {
        let args = request.arguments.map_or_else(|| Value::Object(Default::default()), Value::Object);
        match request.name.as_ref() {
        {{- range $methName, $info := $methods }}
        {{- if not $info.StreamProgress }}
            "{{ $info.ToolName }}" => {
{{- if and $info.MethodOpts $info.MethodOpts.Elicitation }}
                if let Ok(schema) = ElicitationSchema::from_json_schema(
                    serde_json::from_value(json!({
                        "type": "object",
                        "properties": {
                        {{- range $info.MethodOpts.Elicitation.Fields }}
                            "{{ .Name }}": {"type": "{{ .Type }}", "description": "{{ .Description }}"{{ if .EnumValues }}, "enum": [{{ range .EnumValues }}"{{ . }}", {{ end }}]{{ end }}},
                        {{- end }}
                        },
                        "required": [{{ range $info.MethodOpts.Elicitation.Fields }}{{ if .Required }}"{{ .Name }}", {{ end }}{{ end }}]
                    })).unwrap()
                ) {
                    let params = CreateElicitationRequestParams::FormElicitationParams {
                        meta: None,
                        message: {{ $info.MethodOpts.Elicitation.Message | printf "%q" }}.to_string(),
                        requested_schema: schema,
                    };
                    match context.peer.create_elicitation(params).await {
                        Ok(result) if result.action != ElicitationAction::Accept => {
                            return Ok(CallToolResult::success(vec![Content::text("Action cancelled by user.")]));
                        }
                        _ => {} // proceed (including errors â€” graceful degradation)
                    }
                }
{{- end }}
                let result = self.inner.{{ $info.RsMethodName }}(args).await?;
                let text = serde_json::to_string(&result)
                    .map_err(|e| McpError::internal_error(format!("serialize response: {e}"), None))?;
                Ok(CallToolResult::success(vec![Content::text(text)]))
            }
        {{- end }}
        {{- end }}
            _ => Err(McpError::internal_error(format!("unknown tool: {}", request.name), None)),
        }
    }
{{- if $hasPrompts }}

    async fn list_prompts(&self, _: Option<PaginatedRequestParams>, _: RequestContext<RoleServer>) -> Result<ListPromptsResult, McpError> {
        Ok(ListPromptsResult::with_all_items(Self::prompts()))
    }

    async fn get_prompt(&self, request: GetPromptRequestParams, _: RequestContext<RoleServer>) -> Result<GetPromptResult, McpError> {
        for p in Self::prompts() {
            if p.name == request.name {
                let arg_str: String = request.arguments.as_ref()
                    .map(|a| a.iter().map(|(k, v)| format!("{k}={v}")).collect::<Vec<_>>().join(", "))
                    .unwrap_or_default();
                let desc = p.description.clone().unwrap_or_default();
                return Ok(GetPromptResult {
                    description: p.description,
                    messages: vec![PromptMessage {
                        role: PromptMessageRole::User,
                        content: PromptMessageContent::text(format!("{desc} ({arg_str})")),
                    }],
                });
            }
        }
        Err(McpError::invalid_params(format!("unknown prompt: {}", request.name), None))
    }
{{- end }}
{{- if and $svcOpts $svcOpts.Resources }}

    async fn list_resources(&self, _: Option<PaginatedRequestParams>, _: RequestContext<RoleServer>) -> Result<ListResourcesResult, McpError> {
        Ok(ListResourcesResult::with_all_items(Self::resources()))
    }

    async fn list_resource_templates(&self, _: Option<PaginatedRequestParams>, _: RequestContext<RoleServer>) -> Result<ListResourceTemplatesResult, McpError> {
        Ok(ListResourceTemplatesResult::with_all_items(Self::resource_templates()))
    }

    async fn read_resource(&self, request: ReadResourceRequestParams, _: RequestContext<RoleServer>) -> Result<ReadResourceResult, McpError> {
        Ok(ReadResourceResult {
            contents: vec![ResourceContents::text("{}", request.uri)],
        })
    }
{{- end }}
}

pub const {{ $svcName | screamingSnakeCase }}_MCP_DEFAULT_BASE_PATH: &str = "{{ index $.ServiceBasePaths $svcName }}";

{{- $hasStreaming := false }}
{{- range $methName, $info := $methods }}
{{- if $info.StreamProgress }}{{ $hasStreaming = true }}{{ end }}
{{- end }}
{{- if $hasStreaming }}

struct {{ $svcName }}McpEmpty;
#[async_trait]
impl {{ $svcName }}McpServer for {{ $svcName }}McpEmpty {}

/// Client trait for forwarding streaming RPCs. Implement for your gRPC client or use the tonic-generated client.
#[async_trait]
pub trait {{ $svcName }}McpForwardClient: Send + Sync + 'static {
{{- range $methName, $info := $methods }}
{{- if $info.StreamProgress }}
    async fn {{ $info.RsMethodName }}(
        &mut self,
        req: super::{{ $info.RequestType }},
    ) -> std::result::Result<
        tonic::Response<tonic::codec::Streaming<super::{{ $info.StreamChunkType }}>>,
        tonic::Status,
    >;
{{- end }}
{{- end }}
}

/// Handler that forwards tool calls to a gRPC client. Use for services with streaming (progress) RPCs.
pub struct {{ $svcName }}McpForwardHandler<C: {{ $svcName }}McpForwardClient> {
    client: std::sync::Mutex<C>,
}

impl<C: {{ $svcName }}McpForwardClient> {{ $svcName }}McpForwardHandler<C> {
    pub fn new(client: C) -> Self {
        Self { client: std::sync::Mutex::new(client) }
    }
}

impl<C: {{ $svcName }}McpForwardClient> Clone for {{ $svcName }}McpForwardHandler<C>
where
    C: Clone,
{
    fn clone(&self) -> Self {
        Self { client: std::sync::Mutex::new(self.client.lock().unwrap().clone()) }
    }
}

impl<C: {{ $svcName }}McpForwardClient> ServerHandler for {{ $svcName }}McpForwardHandler<C> {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            capabilities: ServerCapabilities::builder().enable_tools().build(),
            server_info: Implementation { name: "{{ $svcName }}".into(), version: "0.1.0".into(), ..Default::default() },
            ..Default::default()
        }
    }

    async fn list_tools(&self, _: Option<PaginatedRequestParams>, _: RequestContext<RoleServer>) -> Result<ListToolsResult, McpError> {
        Ok(ListToolsResult::with_all_items({{ $svcName }}McpHandler::<{{ $svcName }}McpEmpty>::all_tools()))
    }

    async fn call_tool(&self, request: CallToolRequestParams, _context: RequestContext<RoleServer>) -> Result<CallToolResult, McpError> {
        let args = request.arguments.map_or_else(|| Value::Object(Default::default()), Value::Object);
        match request.name.as_ref() {
        {{- range $methName, $info := $methods }}
        {{- if $info.StreamProgress }}
            "{{ $info.ToolName }}" => {
                let req: super::{{ $info.RequestType }} = serde_json::from_value(args)
                    .map_err(|e| McpError::internal_error(format!("parse request: {e}"), None))?;
                let mut guard = self.client.lock().map_err(|_| McpError::internal_error("client lock poisoned", None))?;
                let mut stream = guard.{{ $info.RsMethodName }}(req).await
                    .map_err(|e| McpError::internal_error(format!("gRPC error: {e}"), None))?;
                drop(guard);
                let mut result = None;
                while let Some(chunk) = stream.next().await {
                    let chunk = chunk.map_err(|e| McpError::internal_error(format!("stream error: {e}"), None))?;
                    match chunk.payload {
                        Some(super::{{ $info.StreamChunkType | snakeCase }}::Payload::Progress(_)) => {}
                        Some(super::{{ $info.StreamChunkType | snakeCase }}::Payload::Result(r)) => {
                            result = Some(r);
                            break;
                        }
                        _ => {}
                    }
                }
                let resp = result.ok_or_else(|| McpError::internal_error("stream ended without result", None))?;
                let text = serde_json::to_string(&resp)
                    .map_err(|e| McpError::internal_error(format!("serialize: {e}"), None))?;
                Ok(CallToolResult::success(vec![Content::text(text)]))
            }
        {{- end }}
        {{- end }}
            _ => Err(McpError::internal_error(format!("unknown tool: {}", request.name), None)),
        }
    }
}

/// Implement {{ $svcName }}McpForwardClient for the tonic-generated client.
#[async_trait]
impl<T> {{ $svcName }}McpForwardClient for super::{{ $svcName | snakeCase }}_client::{{ $svcName }}Client<T>
where
    T: tonic::client::GrpcService<tonic::body::Body> + Send + Sync + 'static,
    T::ResponseBody: tonic::body::Body + Send + 'static,
    T::Error: Into<std::boxed::Box<dyn std::error::Error + Send + Sync>>,
{
{{- range $methName, $info := $methods }}
{{- if $info.StreamProgress }}
    async fn {{ $info.RsMethodName }}(
        &mut self,
        req: super::{{ $info.RequestType }},
    ) -> std::result::Result<
        tonic::Response<tonic::codec::Streaming<super::{{ $info.StreamChunkType }}>>,
        tonic::Status,
    > {
        self.{{ $info.RsMethodName }}(req).await
    }
{{- end }}
{{- end }}
}
{{- end }}

pub struct {{ $svcName }}McpTransportConfig {
    pub transport: String,
    pub host: String,
    pub port: u16,
    pub base_path: String,
}

impl Default for {{ $svcName }}McpTransportConfig {
    fn default() -> Self {
        Self { transport: "streamable-http".into(), host: "0.0.0.0".into(), port: 8080,
               base_path: {{ $svcName | screamingSnakeCase }}_MCP_DEFAULT_BASE_PATH.into() }
    }
}

pub async fn serve_{{ $svcName | snakeCase }}_mcp_stdio<T: {{ $svcName }}McpServer>(svc: T) -> Result<(), Box<dyn std::error::Error>> {
    let handler = {{ $svcName }}McpHandler::new(svc);
    handler.serve(rmcp::transport::stdio()).await?.waiting().await?;
    Ok(())
}

pub async fn serve_{{ $svcName | snakeCase }}_mcp<T: {{ $svcName }}McpServer>(
    svc: T, config: {{ $svcName }}McpTransportConfig,
) -> Result<(), Box<dyn std::error::Error>> {
    let handler = {{ $svcName }}McpHandler::new(svc);
    let transports: Vec<&str> = config.transport.split(',').map(|s| s.trim()).filter(|s| !s.is_empty()).collect();
    let has_stdio = transports.iter().any(|t| *t == "stdio");
    let http_transport = transports.iter().find(|t| **t == "sse" || **t == "streamable-http").copied();

    if let Some(_ht) = http_transport {
        use rmcp::transport::streamable_http_server::{
            StreamableHttpServerConfig, StreamableHttpService, session::local::LocalSessionManager,
        };
        let h = handler.clone();
        let http_config = StreamableHttpServerConfig {
            sse_retry: None,
            ..StreamableHttpServerConfig::default()
        };
        let http_service = StreamableHttpService::new(
            move || Ok(h.clone()), Arc::new(LocalSessionManager::default()),
            http_config,
        );
        let app = axum::Router::new().nest_service(&config.base_path, http_service);
        let addr = format!("{}:{}", config.host, config.port);
        let listener = tokio::net::TcpListener::bind(&addr).await?;
        if has_stdio {
            tokio::spawn(async move { axum::serve(listener, app).await.expect("HTTP server failed"); });
        } else {
            axum::serve(listener, app).await?;
            return Ok(());
        }
    }

    if has_stdio {
        handler.serve(rmcp::transport::stdio()).await?.waiting().await?;
    } else if http_transport.is_none() {
        return Err(format!("unsupported transport(s): {}", config.transport).into());
    }
    Ok(())
}
{{- end }}
