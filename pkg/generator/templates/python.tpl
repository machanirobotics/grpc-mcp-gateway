# Code generated by protoc-gen-mcp. DO NOT EDIT.
# Open Source at Machani Robotics - https://github.com/machanirobotics/protoc-mcp-gen
# source: {{ .SourcePath }}

from __future__ import annotations

import json
from typing import Any, Protocol

import mcp.types as types
from mcp.server.fastmcp import FastMCP
from mcp.server.lowlevel import Server
from google.protobuf.json_format import MessageToDict, ParseDict

{{ .PBImports }}

# JSON schemas for each RPC method, used as the inputSchema for MCP tools.
{{- range $key, $val := .SchemaJSON }}
{{ $key }}_SCHEMA = json.loads(r'''{{ $val }}''')
{{- end }}

# MCP tool descriptors. Each pairs a schema with a tool name and description
# so that LLM clients can discover and invoke the underlying RPCs.
{{ range $key, $val := .SchemaJSON }}
{{ $key }}_TOOL = types.Tool(
    name="{{ (index $.ToolMeta $key).Name }}",
    description={{ (index $.ToolMeta $key).Description | pyString }},
    inputSchema={{ $key }}_SCHEMA,
)
{{ end }}

{{- range $svcName, $methods := .Services }}

# Protocol that users implement to handle MCP tool calls backed by
# {{ $svcName }} RPCs. Each method mirrors a unary RPC from the service definition.
class {{ $svcName }}MCPServer(Protocol):
{{- range $methName, $tool := $methods }}
    async def {{ $tool.PyMethodName }}(self, request: {{ $tool.PyRequestType }}) -> {{ $tool.PyResponseType }}: ...
{{- end }}

# gRPC client protocol used when forwarding MCP tool calls to a remote server.
class {{ $svcName }}MCPClient(Protocol):
{{- range $methName, $tool := $methods }}
    async def {{ $tool.PyMethodName }}(self, request: {{ $tool.PyRequestType }}) -> {{ $tool.PyResponseType }}: ...
{{- end }}
{{- end }}

{{- range $svcName, $methods := .Services }}

# Default HTTP path prefix for {{ $svcName }} MCP endpoints,
# derived from the protobuf package and service name.
{{ $svcName }}_MCP_DEFAULT_BASE_PATH = "{{ index $.ServiceBasePaths $svcName }}"

{{- end }}

# Flat list of every tool descriptor, returned by the list_tools handler.
_ALL_TOOLS: list[types.Tool] = [
{{- range $key, $val := .SchemaJSON }}
    {{ $key }}_TOOL,
{{- end }}
]

{{- range $svcName, $methods := .Services }}

def register_{{ $svcName | snakeCase }}_mcp_handler(server: Server, impl: {{ $svcName }}MCPServer) -> None:
    """Register all {{ $svcName }} tools on the given MCP server."""

    @server.list_tools()
    async def handle_list_tools() -> list[types.Tool]:
        return _ALL_TOOLS

    @server.call_tool()
    async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[types.TextContent]:
{{- range $methName, $tool := $methods }}
        if name == "{{ $tool.ToolName }}":
            req = ParseDict(arguments, {{ $tool.PyRequestType }}())
            resp = await impl.{{ $tool.PyMethodName }}(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
{{- end }}
        raise ValueError(f"Unknown tool: {name}")
{{- end }}

{{- range $svcName, $methods := .Services }}

def serve_{{ $svcName | snakeCase }}_mcp(
    impl: {{ $svcName }}MCPServer,
    *,
    transport: str = "streamable-http",
    host: str = "0.0.0.0",
    port: int = 8080,
    path: str | None = None,
) -> None:
    """Create a FastMCP server, register {{ $svcName }} tools, and start serving.

    Supports multiple transports simultaneously via comma-separated values,
    e.g. ``transport="stdio,streamable-http"``.

    Args:
        impl: The service implementation.
        transport: Comma-separated list of "stdio", "sse", "streamable-http".
        host: Bind address for HTTP transports.
        port: Port for HTTP transports.
        path: Base path for HTTP transports (defaults to {{ $svcName }}_MCP_DEFAULT_BASE_PATH).
    """
    import asyncio, contextlib, threading  # noqa: E401
    if path is None:
        path = {{ $svcName }}_MCP_DEFAULT_BASE_PATH

    transports = [t.strip() for t in transport.split(",") if t.strip()]
    has_stdio = "stdio" in transports
    http_transports = [t for t in transports if t in ("sse", "streamable-http")]

    mcp_server = FastMCP("{{ $svcName }}", json_response=True, streamable_http_path="/")
    register_{{ $svcName | snakeCase }}_mcp_handler(mcp_server._mcp_server, impl)

    @contextlib.asynccontextmanager
    async def _lifespan(app):
        async with mcp_server.session_manager.run():
            yield

    if http_transports and has_stdio:
        # Run HTTP in a daemon thread, stdio in the main thread.
        def _run_http() -> None:
            import uvicorn
            from starlette.applications import Starlette
            from starlette.routing import Mount
            ht = http_transports[0]
            mcp_app = mcp_server.sse_app() if ht == "sse" else mcp_server.streamable_http_app()
            app = Starlette(routes=[Mount(path, app=mcp_app)], lifespan=_lifespan)
            cfg = uvicorn.Config(app, host=host, port=port, timeout_graceful_shutdown=0)
            uvicorn.Server(cfg).run()
        threading.Thread(target=_run_http, daemon=True).start()
        mcp_server.run(transport="stdio")
    elif http_transports:
        import uvicorn
        from starlette.applications import Starlette
        from starlette.routing import Mount, Route
        routes: list[Mount | Route] = []
        for ht in http_transports:
            mcp_app = mcp_server.sse_app() if ht == "sse" else mcp_server.streamable_http_app()
            routes.append(Mount(path if ht != "sse" else path, app=mcp_app))
        app = Starlette(routes=routes, lifespan=_lifespan)
        cfg = uvicorn.Config(app, host=host, port=port, timeout_graceful_shutdown=0)
        uvicorn.Server(cfg).run()
    elif has_stdio:
        mcp_server.run(transport="stdio")
    else:
        raise ValueError(f"Unsupported transport(s): {transport}")
{{- end }}

{{- range $svcName, $methods := .Services }}

def forward_to_{{ $svcName | snakeCase }}_mcp_client(server: Server, client: {{ $svcName }}MCPClient) -> None:
    """Register all {{ $svcName }} tools on the MCP server, forwarding each call to a remote gRPC server via the provided client stub."""

    @server.list_tools()
    async def handle_list_tools() -> list[types.Tool]:
        return _ALL_TOOLS

    @server.call_tool()
    async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[types.TextContent]:
{{- range $methName, $tool := $methods }}
        if name == "{{ $tool.ToolName }}":
            req = ParseDict(arguments, {{ $tool.PyRequestType }}())
            resp = await client.{{ $tool.PyMethodName }}(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
{{- end }}
        raise ValueError(f"Unknown tool: {name}")
{{- end }}
