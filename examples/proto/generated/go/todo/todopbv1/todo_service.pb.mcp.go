// Code generated by protoc-gen-mcp. DO NOT EDIT.
// versions:
// 	protoc-gen-mcp v1.4.1-0.20260225155147-715b1d29db15+dirty
// Authors: Machani Robotics - Open Source 2026
// source: todo/v1/todo_service.proto

package todopbv1

import (
	"context"
	"errors"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	"github.com/modelcontextprotocol/go-sdk/mcp"
	"google.golang.org/grpc"
	"google.golang.org/protobuf/encoding/protojson"

	"github.com/machanirobotics/grpc-mcp-gateway/runtime"
)

// JSON schemas for each RPC method, used as the inputSchema for MCP tools.
var TodoService_CreateTodoSchemaJSON = `{"description":"Creates a new todo item under a user. Requires parent (e.g. users/alice), a todo object with title/description/priority, and a unique todo_id.","properties":{"parent":{"description":"Parent resource name (e.g. users/alice). The todo will be created under this user.","type":"string"},"todo":{"properties":{"completed":{"description":"Whether the todo is done.","type":"boolean"},"create_time":{"format":"date-time","type":["string","null"]},"description":{"description":"Optional longer description or notes.","type":"string"},"name":{"description":"Resource name (e.g. users/alice/todos/abc123). Required when updating.","type":"string"},"priority":{"description":"Priority level for a todo item. PRIORITY_UNSPECIFIED: Unspecified; use default priority.. PRIORITY_LOW: Low priority; can be done when convenient.. PRIORITY_MEDIUM: Normal priority; default for most todos.. PRIORITY_HIGH: High priority; should be done soon.. PRIORITY_URGENT: Urgent; do first.","enum":["PRIORITY_UNSPECIFIED","PRIORITY_LOW","PRIORITY_MEDIUM","PRIORITY_HIGH","PRIORITY_URGENT"],"enumDescriptions":{"PRIORITY_HIGH":"High priority; should be done soon.","PRIORITY_LOW":"Low priority; can be done when convenient.","PRIORITY_MEDIUM":"Normal priority; default for most todos.","PRIORITY_UNSPECIFIED":"Unspecified; use default priority.","PRIORITY_URGENT":"Urgent; do first."},"type":"string"},"title":{"description":"Short title for the todo.","type":"string"},"update_time":{"format":"date-time","type":["string","null"]}},"required":[],"type":"object"},"todo_id":{"description":"Unique ID for the todo (e.g. abc123). Becomes the final segment of the resource name.","examples":["abc123","todo-001"],"type":"string"}},"required":["parent","todo","todo_id"],"type":"object"}`
var TodoService_DeleteTodoSchemaJSON = `{"description":"Permanently deletes a todo item by its resource name. This action cannot be undone.","properties":{"name":{"description":"Resource name of the todo to delete (e.g. users/alice/todos/abc123).","type":"string"}},"required":["name"],"type":"object"}`
var TodoService_GetTodoSchemaJSON = `{"description":"Retrieves a single todo item by its resource name (e.g. users/alice/todos/abc123).","properties":{"name":{"description":"Resource name of the todo (e.g. users/alice/todos/abc123).","examples":["users/alice/todos/abc123"],"format":"uri","type":"string"}},"required":["name"],"type":"object"}`
var TodoService_ListTodosSchemaJSON = `{"description":"Lists all todo items for a user. Supports pagination via page_size and page_token.","properties":{"page_size":{"description":"Max number of todos to return (default 50).","type":"integer"},"page_token":{"description":"Token from previous response for next page.","type":"string"},"parent":{"description":"Parent resource name (e.g. users/alice). Lists todos for this user.","type":"string"}},"required":["parent"],"type":"object"}`
var TodoService_UpdateTodoSchemaJSON = `{"description":"Updates an existing todo item. Send the todo with its resource name and the fields to update. Use update_mask to specify which fields to modify.","properties":{"todo":{"properties":{"completed":{"description":"Whether the todo is done.","type":"boolean"},"create_time":{"format":"date-time","type":["string","null"]},"description":{"description":"Optional longer description or notes.","type":"string"},"name":{"description":"Resource name (e.g. users/alice/todos/abc123). Required when updating.","type":"string"},"priority":{"description":"Priority level for a todo item. PRIORITY_UNSPECIFIED: Unspecified; use default priority.. PRIORITY_LOW: Low priority; can be done when convenient.. PRIORITY_MEDIUM: Normal priority; default for most todos.. PRIORITY_HIGH: High priority; should be done soon.. PRIORITY_URGENT: Urgent; do first.","enum":["PRIORITY_UNSPECIFIED","PRIORITY_LOW","PRIORITY_MEDIUM","PRIORITY_HIGH","PRIORITY_URGENT"],"enumDescriptions":{"PRIORITY_HIGH":"High priority; should be done soon.","PRIORITY_LOW":"Low priority; can be done when convenient.","PRIORITY_MEDIUM":"Normal priority; default for most todos.","PRIORITY_UNSPECIFIED":"Unspecified; use default priority.","PRIORITY_URGENT":"Urgent; do first."},"type":"string"},"title":{"description":"Short title for the todo.","type":"string"},"update_time":{"format":"date-time","type":["string","null"]}},"required":[],"type":"object"},"update_mask":{"description":"Comma-separated field names to update (e.g. title,completed). Omit to update all provided fields.","type":"string"}},"required":["todo"],"type":"object"}`

// MCP tool descriptors. Each pairs a schema with a tool name and description
// so that LLM clients can discover and invoke the underlying RPCs.
var (
	TodoService_CreateTodoTool = runtime.MustCreateTool("todo_service-create_todo_v1", `Creates a new todo item under a user. Requires parent (e.g. users/alice), a todo object with title/description/priority, and a unique todo_id.`, TodoService_CreateTodoSchemaJSON)
	TodoService_DeleteTodoTool = runtime.MustCreateTool("todo_service-delete_todo_v1", `Permanently deletes a todo item by its resource name. This action cannot be undone.`, TodoService_DeleteTodoSchemaJSON)
	TodoService_GetTodoTool    = runtime.MustCreateTool("todo_service-get_todo_v1", `Retrieves a single todo item by its resource name (e.g. users/alice/todos/abc123).`, TodoService_GetTodoSchemaJSON)
	TodoService_ListTodosTool  = runtime.MustCreateTool("todo_service-list_todos_v1", `Lists all todo items for a user. Supports pagination via page_size and page_token.`, TodoService_ListTodosSchemaJSON)
	TodoService_UpdateTodoTool = runtime.MustCreateTool("todo_service-update_todo_v1", `Updates an existing todo item. Send the todo with its resource name and the fields to update. Use update_mask to specify which fields to modify.`, TodoService_UpdateTodoSchemaJSON)
)

// TodoServiceMCPServer is the interface that users implement to handle MCP
// tool calls backed by TodoService RPCs. Each method mirrors a unary RPC
// from the protobuf service definition. Server-streaming RPCs (with progress)
// are only supported via ForwardToTodoServiceMCPClient.
type TodoServiceMCPServer interface {
	CreateTodo(ctx context.Context, req *CreateTodoRequest) (*Todo, error)
	DeleteTodo(ctx context.Context, req *DeleteTodoRequest) (*emptypb.Empty, error)
	GetTodo(ctx context.Context, req *GetTodoRequest) (*Todo, error)
	ListTodos(ctx context.Context, req *ListTodosRequest) (*ListTodosResponse, error)
	UpdateTodo(ctx context.Context, req *UpdateTodoRequest) (*Todo, error)
}

// TodoServiceMCPClient is the gRPC client interface used when forwarding MCP
// tool calls to a remote gRPC server. It matches the generated gRPC client stub.
type TodoServiceMCPClient interface {
	CreateTodo(ctx context.Context, req *CreateTodoRequest, opts ...grpc.CallOption) (*Todo, error)
	DeleteTodo(ctx context.Context, req *DeleteTodoRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetTodo(ctx context.Context, req *GetTodoRequest, opts ...grpc.CallOption) (*Todo, error)
	ListTodos(ctx context.Context, req *ListTodosRequest, opts ...grpc.CallOption) (*ListTodosResponse, error)
	UpdateTodo(ctx context.Context, req *UpdateTodoRequest, opts ...grpc.CallOption) (*Todo, error)
}

// RegisterTodoServiceMCPHandler registers all TodoService RPC methods as MCP
// tools, prompts, resources, and apps on the given server based on proto options.
func RegisterTodoServiceMCPHandler(s *mcp.Server, srv TodoServiceMCPServer, opts ...runtime.Option) {
	cfg := runtime.ApplyOptions(opts...)
	_ = cfg
	appResourceURI := runtime.AppResourceURI("TodoService")
	{
		tool := runtime.PrepareToolWithExtras(TodoService_CreateTodoTool, cfg.ExtraProperties)
		tool = runtime.SetToolAppMeta(tool, appResourceURI)
		s.AddTool(tool, func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			elicitResult, elicitErr := runtime.RunElicitation(ctx, req.Session, "Please confirm the todo details before creating.", []runtime.ElicitField{
				{Name: "confirm", Description: "Confirm creation.", Required: true, Type: "string", EnumValues: []string{"yes", "no"}},
			})
			if elicitErr != nil {
				return nil, elicitErr
			}
			if elicitResult.Action != "accept" {
				return runtime.TextResult("Action cancelled by user."), nil
			}
			var pbReq CreateTodoRequest
			args, ctx := runtime.ExtractExtras(ctx, req.Params.Arguments, cfg)
			if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(args, &pbReq); err != nil {
				return nil, err
			}
			resp, err := srv.CreateTodo(ctx, &pbReq)
			if err != nil {
				return runtime.HandleError(err)
			}
			out, err := (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
			if err != nil {
				return nil, err
			}
			return runtime.TextResult(string(out)), nil
		})
	}
	{
		tool := runtime.PrepareToolWithExtras(TodoService_DeleteTodoTool, cfg.ExtraProperties)
		tool = runtime.SetToolAppMeta(tool, appResourceURI)
		s.AddTool(tool, func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			elicitResult, elicitErr := runtime.RunElicitation(ctx, req.Session, "Are you sure you want to delete this todo? This action cannot be undone.", []runtime.ElicitField{
				{Name: "confirm", Description: "Confirm deletion.", Required: true, Type: "string", EnumValues: []string{"yes", "no"}},
			})
			if elicitErr != nil {
				return nil, elicitErr
			}
			if elicitResult.Action != "accept" {
				return runtime.TextResult("Action cancelled by user."), nil
			}
			var pbReq DeleteTodoRequest
			args, ctx := runtime.ExtractExtras(ctx, req.Params.Arguments, cfg)
			if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(args, &pbReq); err != nil {
				return nil, err
			}
			resp, err := srv.DeleteTodo(ctx, &pbReq)
			if err != nil {
				return runtime.HandleError(err)
			}
			out, err := (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
			if err != nil {
				return nil, err
			}
			return runtime.TextResult(string(out)), nil
		})
	}
	{
		tool := runtime.PrepareToolWithExtras(TodoService_GetTodoTool, cfg.ExtraProperties)
		tool = runtime.SetToolAppMeta(tool, appResourceURI)
		s.AddTool(tool, func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			var pbReq GetTodoRequest
			args, ctx := runtime.ExtractExtras(ctx, req.Params.Arguments, cfg)
			if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(args, &pbReq); err != nil {
				return nil, err
			}
			resp, err := srv.GetTodo(ctx, &pbReq)
			if err != nil {
				return runtime.HandleError(err)
			}
			out, err := (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
			if err != nil {
				return nil, err
			}
			return runtime.TextResult(string(out)), nil
		})
	}
	{
		tool := runtime.PrepareToolWithExtras(TodoService_ListTodosTool, cfg.ExtraProperties)
		tool = runtime.SetToolAppMeta(tool, appResourceURI)
		s.AddTool(tool, func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			var pbReq ListTodosRequest
			args, ctx := runtime.ExtractExtras(ctx, req.Params.Arguments, cfg)
			if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(args, &pbReq); err != nil {
				return nil, err
			}
			resp, err := srv.ListTodos(ctx, &pbReq)
			if err != nil {
				return runtime.HandleError(err)
			}
			out, err := (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
			if err != nil {
				return nil, err
			}
			return runtime.TextResult(string(out)), nil
		})
	}
	{
		tool := runtime.PrepareToolWithExtras(TodoService_UpdateTodoTool, cfg.ExtraProperties)
		tool = runtime.SetToolAppMeta(tool, appResourceURI)
		s.AddTool(tool, func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			elicitResult, elicitErr := runtime.RunElicitation(ctx, req.Session, "Please confirm the changes to this todo item.", []runtime.ElicitField{
				{Name: "confirm", Description: "Confirm update.", Required: true, Type: "string", EnumValues: []string{"yes", "no"}},
			})
			if elicitErr != nil {
				return nil, elicitErr
			}
			if elicitResult.Action != "accept" {
				return runtime.TextResult("Action cancelled by user."), nil
			}
			var pbReq UpdateTodoRequest
			args, ctx := runtime.ExtractExtras(ctx, req.Params.Arguments, cfg)
			if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(args, &pbReq); err != nil {
				return nil, err
			}
			resp, err := srv.UpdateTodo(ctx, &pbReq)
			if err != nil {
				return runtime.HandleError(err)
			}
			out, err := (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
			if err != nil {
				return nil, err
			}
			return runtime.TextResult(string(out)), nil
		})
	}
	s.AddResourceTemplate(&mcp.ResourceTemplate{
		URITemplate: "todo://users/{user}/todos/{todo}",
		Name:        "Todo",
		Description: "Todo resource (users/{user}/todos/{todo})",
		MIMEType:    "application/json",
	}, runtime.DefaultResourceHandler())
	s.AddPrompt(&mcp.Prompt{
		Name:        "summarize_todos",
		Description: "Summarize all pending todo items for a user",
		Arguments: []*mcp.PromptArgument{
			{Name: "user", Description: "The user ID to summarize todos for.", Required: true},
		},
	}, runtime.DefaultPromptHandler("Summarize all pending todo items for a user"))
	s.AddPrompt(&mcp.Prompt{
		Name:        "prioritize_todos",
		Description: "Suggest a priority ordering for a user's incomplete todos",
		Arguments: []*mcp.PromptArgument{
			{Name: "user", Description: "The user ID whose todos to prioritize.", Required: true},
			{Name: "strategy", Description: "Prioritization strategy.", Required: false},
		},
	}, runtime.DefaultPromptHandler("Suggest a priority ordering for a user's incomplete todos"))

	s.AddResource(&mcp.Resource{
		URI:      appResourceURI,
		Name:     "Todo App",
		MIMEType: "text/html",
	}, runtime.DefaultAppResourceHandler("Todo App", "1.0.0", "A simple todo management application"))
}

// TodoServiceMCPDefaultBasePath is the default HTTP path prefix for
// TodoService MCP endpoints, derived from the protobuf package and service name.
const TodoServiceMCPDefaultBasePath = "/todo/v1/todoservice/mcp"

// TodoServiceCompletionMap returns a map of "promptName:argName" â†’ allowed
// values, built from enum_values declared in the proto MCP options.
func TodoServiceCompletionMap() map[string][]string {
	m := map[string][]string{}
	m["prioritize_todos:strategy"] = []string{"urgency", "deadline", "effort"}
	return m
}

// ServeTodoServiceMCP creates an MCP server, registers the service tools, and
// starts serving using the configured transport (streamable-http, sse, or stdio).
// Uses the proto-derived BasePath. This is a blocking call.
func ServeTodoServiceMCP(ctx context.Context, srv TodoServiceMCPServer, cfg *runtime.MCPServerConfig, opts ...runtime.Option) error {
	// Set the proto-derived path as the generated default
	cfg.GeneratedBasePath = TodoServiceMCPDefaultBasePath

	// Wire completion handler for prompt arguments with enum_values.
	completionMap := TodoServiceCompletionMap()
	if len(completionMap) > 0 {
		if cfg.ServerOptions == nil {
			cfg.ServerOptions = &mcp.ServerOptions{}
		}
		cfg.ServerOptions.CompletionHandler = runtime.CompletionHandlerFromEnums(completionMap)
	}

	return runtime.StartServer(ctx, cfg, func(s *mcp.Server) {
		RegisterTodoServiceMCPHandler(s, srv, opts...)
	})
}

// ForwardToTodoServiceMCPClient registers all TodoService tools, prompts,
// resources, and apps on the MCP server, forwarding every tool call to a
// remote gRPC server via the provided client stub.
func ForwardToTodoServiceMCPClient(s *mcp.Server, client TodoServiceMCPClient, opts ...runtime.Option) {
	cfg := runtime.ApplyOptions(opts...)
	appResourceURI := runtime.AppResourceURI("TodoService")
	{
		tool := runtime.PrepareToolWithExtras(TodoService_CreateTodoTool, cfg.ExtraProperties)
		tool = runtime.SetToolAppMeta(tool, appResourceURI)
		s.AddTool(tool, func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			elicitResult, elicitErr := runtime.RunElicitation(ctx, req.Session, "Please confirm the todo details before creating.", []runtime.ElicitField{
				{Name: "confirm", Description: "Confirm creation.", Required: true, Type: "string", EnumValues: []string{"yes", "no"}},
			})
			if elicitErr != nil {
				return nil, elicitErr
			}
			if elicitResult.Action != "accept" {
				return runtime.TextResult("Action cancelled by user."), nil
			}
			var pbReq CreateTodoRequest
			args, ctx := runtime.ExtractExtras(ctx, req.Params.Arguments, cfg)
			if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(args, &pbReq); err != nil {
				return nil, err
			}
			ctx = runtime.ForwardMetadata(ctx)
			resp, err := client.CreateTodo(ctx, &pbReq)
			if err != nil {
				return runtime.HandleError(err)
			}
			out, err := (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
			if err != nil {
				return nil, err
			}
			return runtime.TextResult(string(out)), nil
		})
	}
	{
		tool := runtime.PrepareToolWithExtras(TodoService_DeleteTodoTool, cfg.ExtraProperties)
		tool = runtime.SetToolAppMeta(tool, appResourceURI)
		s.AddTool(tool, func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			elicitResult, elicitErr := runtime.RunElicitation(ctx, req.Session, "Are you sure you want to delete this todo? This action cannot be undone.", []runtime.ElicitField{
				{Name: "confirm", Description: "Confirm deletion.", Required: true, Type: "string", EnumValues: []string{"yes", "no"}},
			})
			if elicitErr != nil {
				return nil, elicitErr
			}
			if elicitResult.Action != "accept" {
				return runtime.TextResult("Action cancelled by user."), nil
			}
			var pbReq DeleteTodoRequest
			args, ctx := runtime.ExtractExtras(ctx, req.Params.Arguments, cfg)
			if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(args, &pbReq); err != nil {
				return nil, err
			}
			ctx = runtime.ForwardMetadata(ctx)
			resp, err := client.DeleteTodo(ctx, &pbReq)
			if err != nil {
				return runtime.HandleError(err)
			}
			out, err := (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
			if err != nil {
				return nil, err
			}
			return runtime.TextResult(string(out)), nil
		})
	}
	{
		tool := runtime.PrepareToolWithExtras(TodoService_GetTodoTool, cfg.ExtraProperties)
		tool = runtime.SetToolAppMeta(tool, appResourceURI)
		s.AddTool(tool, func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			var pbReq GetTodoRequest
			args, ctx := runtime.ExtractExtras(ctx, req.Params.Arguments, cfg)
			if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(args, &pbReq); err != nil {
				return nil, err
			}
			ctx = runtime.ForwardMetadata(ctx)
			resp, err := client.GetTodo(ctx, &pbReq)
			if err != nil {
				return runtime.HandleError(err)
			}
			out, err := (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
			if err != nil {
				return nil, err
			}
			return runtime.TextResult(string(out)), nil
		})
	}
	{
		tool := runtime.PrepareToolWithExtras(TodoService_ListTodosTool, cfg.ExtraProperties)
		tool = runtime.SetToolAppMeta(tool, appResourceURI)
		s.AddTool(tool, func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			var pbReq ListTodosRequest
			args, ctx := runtime.ExtractExtras(ctx, req.Params.Arguments, cfg)
			if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(args, &pbReq); err != nil {
				return nil, err
			}
			ctx = runtime.ForwardMetadata(ctx)
			resp, err := client.ListTodos(ctx, &pbReq)
			if err != nil {
				return runtime.HandleError(err)
			}
			out, err := (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
			if err != nil {
				return nil, err
			}
			return runtime.TextResult(string(out)), nil
		})
	}
	{
		tool := runtime.PrepareToolWithExtras(TodoService_UpdateTodoTool, cfg.ExtraProperties)
		tool = runtime.SetToolAppMeta(tool, appResourceURI)
		s.AddTool(tool, func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			elicitResult, elicitErr := runtime.RunElicitation(ctx, req.Session, "Please confirm the changes to this todo item.", []runtime.ElicitField{
				{Name: "confirm", Description: "Confirm update.", Required: true, Type: "string", EnumValues: []string{"yes", "no"}},
			})
			if elicitErr != nil {
				return nil, elicitErr
			}
			if elicitResult.Action != "accept" {
				return runtime.TextResult("Action cancelled by user."), nil
			}
			var pbReq UpdateTodoRequest
			args, ctx := runtime.ExtractExtras(ctx, req.Params.Arguments, cfg)
			if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(args, &pbReq); err != nil {
				return nil, err
			}
			ctx = runtime.ForwardMetadata(ctx)
			resp, err := client.UpdateTodo(ctx, &pbReq)
			if err != nil {
				return runtime.HandleError(err)
			}
			out, err := (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
			if err != nil {
				return nil, err
			}
			return runtime.TextResult(string(out)), nil
		})
	}
	s.AddResourceTemplate(&mcp.ResourceTemplate{
		URITemplate: "todo://users/{user}/todos/{todo}",
		Name:        "Todo",
		Description: "Todo resource (users/{user}/todos/{todo})",
		MIMEType:    "application/json",
	}, runtime.DefaultResourceHandler())
	s.AddPrompt(&mcp.Prompt{
		Name:        "summarize_todos",
		Description: "Summarize all pending todo items for a user",
		Arguments: []*mcp.PromptArgument{
			{Name: "user", Description: "The user ID to summarize todos for.", Required: true},
		},
	}, runtime.DefaultPromptHandler("Summarize all pending todo items for a user"))
	s.AddPrompt(&mcp.Prompt{
		Name:        "prioritize_todos",
		Description: "Suggest a priority ordering for a user's incomplete todos",
		Arguments: []*mcp.PromptArgument{
			{Name: "user", Description: "The user ID whose todos to prioritize.", Required: true},
			{Name: "strategy", Description: "Prioritization strategy.", Required: false},
		},
	}, runtime.DefaultPromptHandler("Suggest a priority ordering for a user's incomplete todos"))

	s.AddResource(&mcp.Resource{
		URI:      appResourceURI,
		Name:     "Todo App",
		MIMEType: "text/html",
	}, runtime.DefaultAppResourceHandler("Todo App", "1.0.0", "A simple todo management application"))
}
