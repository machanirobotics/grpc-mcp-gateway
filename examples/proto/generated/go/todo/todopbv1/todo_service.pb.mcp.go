// Code generated by protoc-gen-mcp. DO NOT EDIT.
// Open Source at Machani Robotics - https://github.com/machanirobotics/protoc-mcp-gen
// source: todo/v1/todo_service.proto

package todopbv1

import (
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

import (
	"context"

	"github.com/modelcontextprotocol/go-sdk/mcp"
	"google.golang.org/grpc"
	"google.golang.org/protobuf/encoding/protojson"

	"github.com/machanirobotics/protoc-mcp-gen/pkg/runtime"
)

// JSON schemas for each RPC method, used as the inputSchema for MCP tools.
var TodoService_CreateTodoSchemaJSON = `{"properties":{"parent":{"type":"string"},"todo":{"properties":{"completed":{"type":"boolean"},"create_time":{"format":"date-time","type":["string","null"]},"description":{"type":"string"},"name":{"type":"string"},"priority":{"enum":["PRIORITY_UNSPECIFIED","PRIORITY_LOW","PRIORITY_MEDIUM","PRIORITY_HIGH","PRIORITY_URGENT"],"type":"string"},"title":{"type":"string"},"update_time":{"format":"date-time","type":["string","null"]}},"required":[],"type":"object"},"todo_id":{"type":"string"}},"required":["parent","todo","todo_id"],"type":"object"}`
var TodoService_DeleteTodoSchemaJSON = `{"properties":{"name":{"type":"string"}},"required":["name"],"type":"object"}`
var TodoService_GetTodoSchemaJSON = `{"properties":{"name":{"type":"string"}},"required":["name"],"type":"object"}`
var TodoService_ListTodosSchemaJSON = `{"properties":{"page_size":{"type":"integer"},"page_token":{"type":"string"},"parent":{"type":"string"}},"required":["parent"],"type":"object"}`
var TodoService_UpdateTodoSchemaJSON = `{"properties":{"todo":{"properties":{"completed":{"type":"boolean"},"create_time":{"format":"date-time","type":["string","null"]},"description":{"type":"string"},"name":{"type":"string"},"priority":{"enum":["PRIORITY_UNSPECIFIED","PRIORITY_LOW","PRIORITY_MEDIUM","PRIORITY_HIGH","PRIORITY_URGENT"],"type":"string"},"title":{"type":"string"},"update_time":{"format":"date-time","type":["string","null"]}},"required":[],"type":"object"},"update_mask":{"type":"string"}},"required":["todo"],"type":"object"}`

// MCP tool descriptors. Each pairs a schema with a tool name and description
// so that LLM clients can discover and invoke the underlying RPCs.
var (
	TodoService_CreateTodoTool = runtime.MustCreateTool("todo_v1_TodoService_CreateTodo", `Creates a new todo item.
`, TodoService_CreateTodoSchemaJSON)
	TodoService_DeleteTodoTool = runtime.MustCreateTool("todo_v1_TodoService_DeleteTodo", `Deletes a todo item by resource name.
`, TodoService_DeleteTodoSchemaJSON)
	TodoService_GetTodoTool = runtime.MustCreateTool("todo_v1_TodoService_GetTodo", `Retrieves a todo item by resource name.
`, TodoService_GetTodoSchemaJSON)
	TodoService_ListTodosTool = runtime.MustCreateTool("todo_v1_TodoService_ListTodos", `Lists todo items with optional filtering.
`, TodoService_ListTodosSchemaJSON)
	TodoService_UpdateTodoTool = runtime.MustCreateTool("todo_v1_TodoService_UpdateTodo", `Updates an existing todo item.
`, TodoService_UpdateTodoSchemaJSON)
)

// TodoServiceMCPServer is the interface that users implement to handle MCP
// tool calls backed by TodoService RPCs. Each method mirrors a unary RPC
// from the protobuf service definition.
type TodoServiceMCPServer interface {
	CreateTodo(ctx context.Context, req *CreateTodoRequest) (*Todo, error)
	DeleteTodo(ctx context.Context, req *DeleteTodoRequest) (*emptypb.Empty, error)
	GetTodo(ctx context.Context, req *GetTodoRequest) (*Todo, error)
	ListTodos(ctx context.Context, req *ListTodosRequest) (*ListTodosResponse, error)
	UpdateTodo(ctx context.Context, req *UpdateTodoRequest) (*Todo, error)
}

// TodoServiceMCPClient is the gRPC client interface used when forwarding MCP
// tool calls to a remote gRPC server. It matches the generated gRPC client stub.
type TodoServiceMCPClient interface {
	CreateTodo(ctx context.Context, req *CreateTodoRequest, opts ...grpc.CallOption) (*Todo, error)
	DeleteTodo(ctx context.Context, req *DeleteTodoRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetTodo(ctx context.Context, req *GetTodoRequest, opts ...grpc.CallOption) (*Todo, error)
	ListTodos(ctx context.Context, req *ListTodosRequest, opts ...grpc.CallOption) (*ListTodosResponse, error)
	UpdateTodo(ctx context.Context, req *UpdateTodoRequest, opts ...grpc.CallOption) (*Todo, error)
}

// RegisterTodoServiceMCPHandler registers all TodoService RPC methods as MCP
// tools on the given server. Each incoming tool call is deserialized from JSON
// into the corresponding protobuf request, dispatched to srv, and the protobuf
// response is serialized back to JSON.
func RegisterTodoServiceMCPHandler(s *mcp.Server, srv TodoServiceMCPServer, opts ...runtime.Option) {
	cfg := runtime.ApplyOptions(opts...)
	{
		tool := runtime.PrepareToolWithExtras(TodoService_CreateTodoTool, cfg.ExtraProperties)
		s.AddTool(tool, func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			var pbReq CreateTodoRequest
			args, ctx := runtime.ExtractExtras(ctx, req.Params.Arguments, cfg)
			if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(args, &pbReq); err != nil {
				return nil, err
			}
			resp, err := srv.CreateTodo(ctx, &pbReq)
			if err != nil {
				return runtime.HandleError(err)
			}
			out, err := (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
			if err != nil {
				return nil, err
			}
			return runtime.TextResult(string(out)), nil
		})
	}
	{
		tool := runtime.PrepareToolWithExtras(TodoService_DeleteTodoTool, cfg.ExtraProperties)
		s.AddTool(tool, func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			var pbReq DeleteTodoRequest
			args, ctx := runtime.ExtractExtras(ctx, req.Params.Arguments, cfg)
			if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(args, &pbReq); err != nil {
				return nil, err
			}
			resp, err := srv.DeleteTodo(ctx, &pbReq)
			if err != nil {
				return runtime.HandleError(err)
			}
			out, err := (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
			if err != nil {
				return nil, err
			}
			return runtime.TextResult(string(out)), nil
		})
	}
	{
		tool := runtime.PrepareToolWithExtras(TodoService_GetTodoTool, cfg.ExtraProperties)
		s.AddTool(tool, func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			var pbReq GetTodoRequest
			args, ctx := runtime.ExtractExtras(ctx, req.Params.Arguments, cfg)
			if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(args, &pbReq); err != nil {
				return nil, err
			}
			resp, err := srv.GetTodo(ctx, &pbReq)
			if err != nil {
				return runtime.HandleError(err)
			}
			out, err := (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
			if err != nil {
				return nil, err
			}
			return runtime.TextResult(string(out)), nil
		})
	}
	{
		tool := runtime.PrepareToolWithExtras(TodoService_ListTodosTool, cfg.ExtraProperties)
		s.AddTool(tool, func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			var pbReq ListTodosRequest
			args, ctx := runtime.ExtractExtras(ctx, req.Params.Arguments, cfg)
			if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(args, &pbReq); err != nil {
				return nil, err
			}
			resp, err := srv.ListTodos(ctx, &pbReq)
			if err != nil {
				return runtime.HandleError(err)
			}
			out, err := (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
			if err != nil {
				return nil, err
			}
			return runtime.TextResult(string(out)), nil
		})
	}
	{
		tool := runtime.PrepareToolWithExtras(TodoService_UpdateTodoTool, cfg.ExtraProperties)
		s.AddTool(tool, func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			var pbReq UpdateTodoRequest
			args, ctx := runtime.ExtractExtras(ctx, req.Params.Arguments, cfg)
			if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(args, &pbReq); err != nil {
				return nil, err
			}
			resp, err := srv.UpdateTodo(ctx, &pbReq)
			if err != nil {
				return runtime.HandleError(err)
			}
			out, err := (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
			if err != nil {
				return nil, err
			}
			return runtime.TextResult(string(out)), nil
		})
	}
}

// TodoServiceMCPDefaultBasePath is the default HTTP path prefix for
// TodoService MCP endpoints, derived from the protobuf package and service name.
const TodoServiceMCPDefaultBasePath = "/todo/v1/todoservice/mcp"

// ServeTodoServiceMCP creates an MCP server, registers the service tools, and
// starts serving using the configured transport (streamable-http, sse, or stdio).
// If cfg.BasePath is empty it defaults to TodoServiceMCPDefaultBasePath.
// This is a blocking call.
func ServeTodoServiceMCP(ctx context.Context, srv TodoServiceMCPServer, cfg *runtime.MCPServerConfig, opts ...runtime.Option) error {
	if cfg.BasePath == "" {
		cfg.BasePath = TodoServiceMCPDefaultBasePath
	}
	return runtime.StartServer(ctx, cfg, func(s *mcp.Server) {
		RegisterTodoServiceMCPHandler(s, srv, opts...)
	})
}

// ForwardToTodoServiceMCPClient registers all TodoService tools on the MCP
// server, but instead of calling a local implementation it forwards every tool
// call to a remote gRPC server via the provided client stub.
func ForwardToTodoServiceMCPClient(s *mcp.Server, client TodoServiceMCPClient, opts ...runtime.Option) {
	cfg := runtime.ApplyOptions(opts...)
	{
		tool := runtime.PrepareToolWithExtras(TodoService_CreateTodoTool, cfg.ExtraProperties)
		s.AddTool(tool, func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			var pbReq CreateTodoRequest
			args, ctx := runtime.ExtractExtras(ctx, req.Params.Arguments, cfg)
			if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(args, &pbReq); err != nil {
				return nil, err
			}
			resp, err := client.CreateTodo(ctx, &pbReq)
			if err != nil {
				return runtime.HandleError(err)
			}
			out, err := (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
			if err != nil {
				return nil, err
			}
			return runtime.TextResult(string(out)), nil
		})
	}
	{
		tool := runtime.PrepareToolWithExtras(TodoService_DeleteTodoTool, cfg.ExtraProperties)
		s.AddTool(tool, func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			var pbReq DeleteTodoRequest
			args, ctx := runtime.ExtractExtras(ctx, req.Params.Arguments, cfg)
			if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(args, &pbReq); err != nil {
				return nil, err
			}
			resp, err := client.DeleteTodo(ctx, &pbReq)
			if err != nil {
				return runtime.HandleError(err)
			}
			out, err := (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
			if err != nil {
				return nil, err
			}
			return runtime.TextResult(string(out)), nil
		})
	}
	{
		tool := runtime.PrepareToolWithExtras(TodoService_GetTodoTool, cfg.ExtraProperties)
		s.AddTool(tool, func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			var pbReq GetTodoRequest
			args, ctx := runtime.ExtractExtras(ctx, req.Params.Arguments, cfg)
			if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(args, &pbReq); err != nil {
				return nil, err
			}
			resp, err := client.GetTodo(ctx, &pbReq)
			if err != nil {
				return runtime.HandleError(err)
			}
			out, err := (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
			if err != nil {
				return nil, err
			}
			return runtime.TextResult(string(out)), nil
		})
	}
	{
		tool := runtime.PrepareToolWithExtras(TodoService_ListTodosTool, cfg.ExtraProperties)
		s.AddTool(tool, func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			var pbReq ListTodosRequest
			args, ctx := runtime.ExtractExtras(ctx, req.Params.Arguments, cfg)
			if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(args, &pbReq); err != nil {
				return nil, err
			}
			resp, err := client.ListTodos(ctx, &pbReq)
			if err != nil {
				return runtime.HandleError(err)
			}
			out, err := (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
			if err != nil {
				return nil, err
			}
			return runtime.TextResult(string(out)), nil
		})
	}
	{
		tool := runtime.PrepareToolWithExtras(TodoService_UpdateTodoTool, cfg.ExtraProperties)
		s.AddTool(tool, func(ctx context.Context, req *mcp.CallToolRequest) (*mcp.CallToolResult, error) {
			var pbReq UpdateTodoRequest
			args, ctx := runtime.ExtractExtras(ctx, req.Params.Arguments, cfg)
			if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(args, &pbReq); err != nil {
				return nil, err
			}
			resp, err := client.UpdateTodo(ctx, &pbReq)
			if err != nil {
				return runtime.HandleError(err)
			}
			out, err := (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
			if err != nil {
				return nil, err
			}
			return runtime.TextResult(string(out)), nil
		})
	}
}
