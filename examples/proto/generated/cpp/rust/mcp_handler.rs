// Code generated by protoc-gen-mcp. DO NOT EDIT.
// versions:
// 	protoc-gen-mcp v1.2.3+dirty
// Authors: Machani Robotics - Open Source 2026
// source: todo/v1/todo_service.proto

use std::sync::Arc;
use rmcp::{ErrorData as McpError, RoleServer, ServerHandler, ServiceExt, model::*, service::RequestContext};
use serde_json::{self, json, Value};

fn make_tool(name: &str, description: &str, schema_json: &str) -> Tool {
    serde_json::from_value(json!({
        "name": name, "description": description,
        "inputSchema": serde_json::from_str::<Value>(schema_json).unwrap(),
    })).expect("generated tool schema must be valid")
}

const TODO_SERVICE__CREATE_TODO_SCHEMA_JSON: &str = r##"{"properties":{"parent":{"type":"string"},"todo":{"properties":{"completed":{"type":"boolean"},"create_time":{"format":"date-time","type":["string","null"]},"description":{"type":"string"},"name":{"type":"string"},"priority":{"enum":["PRIORITY_UNSPECIFIED","PRIORITY_LOW","PRIORITY_MEDIUM","PRIORITY_HIGH","PRIORITY_URGENT"],"type":"string"},"title":{"type":"string"},"update_time":{"format":"date-time","type":["string","null"]}},"required":[],"type":"object"},"todo_id":{"type":"string"}},"required":["parent","todo","todo_id"],"type":"object"}"##;
const TODO_SERVICE__DELETE_TODO_SCHEMA_JSON: &str = r##"{"properties":{"name":{"type":"string"}},"required":["name"],"type":"object"}"##;
const TODO_SERVICE__GET_TODO_SCHEMA_JSON: &str = r##"{"properties":{"name":{"type":"string"}},"required":["name"],"type":"object"}"##;
const TODO_SERVICE__LIST_TODOS_SCHEMA_JSON: &str = r##"{"properties":{"page_size":{"type":"integer"},"page_token":{"type":"string"},"parent":{"type":"string"}},"required":["parent"],"type":"object"}"##;
const TODO_SERVICE__UPDATE_TODO_SCHEMA_JSON: &str = r##"{"properties":{"todo":{"properties":{"completed":{"type":"boolean"},"create_time":{"format":"date-time","type":["string","null"]},"description":{"type":"string"},"name":{"type":"string"},"priority":{"enum":["PRIORITY_UNSPECIFIED","PRIORITY_LOW","PRIORITY_MEDIUM","PRIORITY_HIGH","PRIORITY_URGENT"],"type":"string"},"title":{"type":"string"},"update_time":{"format":"date-time","type":["string","null"]}},"required":[],"type":"object"},"update_mask":{"type":"string"}},"required":["todo"],"type":"object"}"##;

pub struct TodoServiceMcpHandler {
    inner: cxx::UniquePtr<crate::ffi_todo_service::TodoServiceMcpImpl>,
}

unsafe impl Send for TodoServiceMcpHandler {}
unsafe impl Sync for TodoServiceMcpHandler {}

impl TodoServiceMcpHandler {
    pub fn new() -> Self {
        Self { inner: crate::ffi_todo_service::new_todo_service_mcp() }
    }

    fn tools() -> Vec<Tool> {
        vec![
            make_tool("todo_service-create_todo_v1", "Creates a new todo item under a user. Requires parent (e.g. users/alice), a todo object with title/description/priority, and a unique todo_id.", TODO_SERVICE__CREATE_TODO_SCHEMA_JSON),
            make_tool("todo_service-delete_todo_v1", "Permanently deletes a todo item by its resource name. This action cannot be undone.", TODO_SERVICE__DELETE_TODO_SCHEMA_JSON),
            make_tool("todo_service-get_todo_v1", "Retrieves a single todo item by its resource name (e.g. users/alice/todos/abc123).", TODO_SERVICE__GET_TODO_SCHEMA_JSON),
            make_tool("todo_service-list_todos_v1", "Lists all todo items for a user. Supports pagination via page_size and page_token.", TODO_SERVICE__LIST_TODOS_SCHEMA_JSON),
            make_tool("todo_service-update_todo_v1", "Updates an existing todo item. Send the todo with its resource name and the fields to update. Use update_mask to specify which fields to modify.", TODO_SERVICE__UPDATE_TODO_SCHEMA_JSON),
        ]
    }
}

impl Clone for TodoServiceMcpHandler {
    fn clone(&self) -> Self { Self::new() }
}

impl ServerHandler for TodoServiceMcpHandler {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            capabilities: ServerCapabilities::builder()
                .enable_tools()
                .build(),
            server_info: Implementation { name: "TodoService".into(), version: "0.1.0".into(), ..Default::default() },
            ..Default::default()
        }
    }

    async fn list_tools(&self, _: Option<PaginatedRequestParams>, _: RequestContext<RoleServer>) -> Result<ListToolsResult, McpError> {
        Ok(ListToolsResult::with_all_items(Self::tools()))
    }

    async fn call_tool(&self, request: CallToolRequestParams, _: RequestContext<RoleServer>) -> Result<CallToolResult, McpError> {
        let args = request.arguments.map_or_else(|| Value::Object(Default::default()), Value::Object);
        let args_json = serde_json::to_string(&args)
            .map_err(|e| McpError::internal_error(format!("serialize args: {e}"), None))?;
        let result_json = match request.name.as_ref() {
            "todo_service-create_todo_v1" => self.inner.create_todo(&args_json),
            "todo_service-delete_todo_v1" => self.inner.delete_todo(&args_json),
            "todo_service-get_todo_v1" => self.inner.get_todo(&args_json),
            "todo_service-list_todos_v1" => self.inner.list_todos(&args_json),
            "todo_service-update_todo_v1" => self.inner.update_todo(&args_json),
            _ => return Err(McpError::internal_error(format!("unknown tool: {}", request.name), None)),
        };
        Ok(CallToolResult::success(vec![Content::text(result_json)]))
    }
}

pub const TODO_SERVICE_MCP_DEFAULT_BASE_PATH: &str = "/todo/v1/todoservice/mcp";

pub async fn serve_todo_service_mcp_stdio() -> Result<(), Box<dyn std::error::Error>> {
    let handler = TodoServiceMcpHandler::new();
    handler.serve(rmcp::transport::stdio()).await?.waiting().await?;
    Ok(())
}

pub async fn serve_todo_service_mcp(
    host: &str, port: u16, base_path: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let handler = TodoServiceMcpHandler::new();
    use rmcp::transport::streamable_http_server::{
        StreamableHttpServerConfig, StreamableHttpService, session::local::LocalSessionManager,
    };
    let config = StreamableHttpServerConfig::default();
    let h = handler.clone();
    let service = StreamableHttpService::new(
        move || Ok(h.clone()), Arc::new(LocalSessionManager::default()), config,
    );
    let app = axum::Router::new().nest_service(base_path, service);
    let addr = format!("{host}:{port}");
    let listener = tokio::net::TcpListener::bind(&addr).await?;
    eprintln!("MCP server listening on {addr}{base_path}");
    axum::serve(listener, app).await?;
    Ok(())
}

