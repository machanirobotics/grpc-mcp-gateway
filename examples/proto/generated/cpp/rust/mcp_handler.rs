// Code generated by protoc-gen-mcp. DO NOT EDIT.
// versions:
// 	protoc-gen-mcp v1.3.4-0.20260225060520-7b3b28c62629+dirty
// Authors: Machani Robotics - Open Source 2026
// source: counter/v1/counter_service.proto

use std::sync::Arc;
use rmcp::{ErrorData as McpError, RoleServer, ServerHandler, ServiceExt, model::*, service::RequestContext};
use serde_json::{self, json, Value};

fn make_tool(name: &str, description: &str, schema_json: &str) -> Tool {
    serde_json::from_value(json!({
        "name": name, "description": description,
        "inputSchema": serde_json::from_str::<Value>(schema_json).unwrap(),
    })).expect("generated tool schema must be valid")
}


pub struct CounterServiceMcpHandler {
    inner: cxx::UniquePtr<crate::ffi_counter_service::CounterServiceMcpImpl>,
}

unsafe impl Send for CounterServiceMcpHandler {}
unsafe impl Sync for CounterServiceMcpHandler {}

impl CounterServiceMcpHandler {
    pub fn new() -> Self {
        Self { inner: crate::ffi_counter_service::new_counter_service_mcp() }
    }

    fn tools() -> Vec<Tool> {
        vec![
        ]
    }
}

impl Clone for CounterServiceMcpHandler {
    fn clone(&self) -> Self { Self::new() }
}

impl ServerHandler for CounterServiceMcpHandler {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            capabilities: ServerCapabilities::builder()
                .enable_tools()
                .build(),
            server_info: Implementation { name: "CounterService".into(), version: "0.1.0".into(), ..Default::default() },
            ..Default::default()
        }
    }

    async fn list_tools(&self, _: Option<PaginatedRequestParams>, _: RequestContext<RoleServer>) -> Result<ListToolsResult, McpError> {
        Ok(ListToolsResult::with_all_items(Self::tools()))
    }

    async fn call_tool(&self, request: CallToolRequestParams, _: RequestContext<RoleServer>) -> Result<CallToolResult, McpError> {
        let args = request.arguments.map_or_else(|| Value::Object(Default::default()), Value::Object);
        let args_json = serde_json::to_string(&args)
            .map_err(|e| McpError::internal_error(format!("serialize args: {e}"), None))?;
        let result_json = match request.name.as_ref() {
            _ => return Err(McpError::internal_error(format!("unknown tool: {}", request.name), None)),
        };
        Ok(CallToolResult::success(vec![Content::text(result_json)]))
    }
}

pub const COUNTER_SERVICE_MCP_DEFAULT_BASE_PATH: &str = "/counter/v1/counterservice/mcp";

pub async fn serve_counter_service_mcp_stdio() -> Result<(), Box<dyn std::error::Error>> {
    let handler = CounterServiceMcpHandler::new();
    handler.serve(rmcp::transport::stdio()).await?.waiting().await?;
    Ok(())
}

pub async fn serve_counter_service_mcp(
    host: &str, port: u16, base_path: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let handler = CounterServiceMcpHandler::new();
    use rmcp::transport::streamable_http_server::{
        StreamableHttpServerConfig, StreamableHttpService, session::local::LocalSessionManager,
    };
    let config = StreamableHttpServerConfig::default();
    let h = handler.clone();
    let service = StreamableHttpService::new(
        move || Ok(h.clone()), Arc::new(LocalSessionManager::default()), config,
    );
    let app = axum::Router::new().nest_service(base_path, service);
    let addr = format!("{host}:{port}");
    let listener = tokio::net::TcpListener::bind(&addr).await?;
    eprintln!("MCP server listening on {addr}{base_path}");
    axum::serve(listener, app).await?;
    Ok(())
}

