// Code generated by protoc-gen-mcp. DO NOT EDIT.
// versions:
// 	protoc-gen-mcp v1.3.4-0.20260225060520-7b3b28c62629+dirty
// Authors: Machani Robotics - Open Source 2026
// source: todo/v1/todo_service.proto

#[cxx::bridge(namespace = "todo::v1")]
mod ffi_todo_service {
    unsafe extern "C++" {
        include!("todo/v1/todo_service.mcp.h");

        type TodoServiceMcpImpl;
        fn create_todo(self: &TodoServiceMcpImpl, args_json: &str) -> String;
        fn delete_todo(self: &TodoServiceMcpImpl, args_json: &str) -> String;
        fn get_todo(self: &TodoServiceMcpImpl, args_json: &str) -> String;
        fn list_todos(self: &TodoServiceMcpImpl, args_json: &str) -> String;
        fn update_todo(self: &TodoServiceMcpImpl, args_json: &str) -> String;

        fn new_todo_service_mcp() -> UniquePtr<TodoServiceMcpImpl>;
    }

    extern "Rust" {
        fn start_todo_service_mcp_http(host: &str, port: u16, base_path: &str);
        fn start_todo_service_mcp_stdio();
    }
}

pub mod mcp_handler;

fn start_todo_service_mcp_http(host: &str, port: u16, base_path: &str) {
    let rt = tokio::runtime::Runtime::new().expect("failed to create tokio runtime");
    rt.block_on(async {
        if let Err(e) = mcp_handler::serve_todo_service_mcp(host, port, base_path).await {
            eprintln!("MCP HTTP server failed: {e}");
            eprintln!("Hint: Port {port} may be in use. Try MCP_PORT=8083 ./server or kill the process using the port.");
            std::process::exit(1);
        }
    });
}

fn start_todo_service_mcp_stdio() {
    let rt = tokio::runtime::Runtime::new().expect("failed to create tokio runtime");
    rt.block_on(async {
        mcp_handler::serve_todo_service_mcp_stdio()
            .await
            .expect("MCP stdio server failed");
    });
}

