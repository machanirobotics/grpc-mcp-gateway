// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: todo/v1/todo_service.proto
#ifndef GRPC_todo_2fv1_2ftodo_5fservice_2eproto__INCLUDED
#define GRPC_todo_2fv1_2ftodo_5fservice_2eproto__INCLUDED

#include "todo/v1/todo_service.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>
#include <grpcpp/ports_def.inc>

namespace todo {
namespace v1 {

// Service for managing todo items.
class TodoService final {
 public:
  static constexpr char const* service_full_name() {
    return "todo.v1.TodoService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Creates a new todo item.
    virtual ::grpc::Status CreateTodo(::grpc::ClientContext* context, const ::todo::v1::CreateTodoRequest& request, ::todo::v1::Todo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::Todo>> AsyncCreateTodo(::grpc::ClientContext* context, const ::todo::v1::CreateTodoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::Todo>>(AsyncCreateTodoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::Todo>> PrepareAsyncCreateTodo(::grpc::ClientContext* context, const ::todo::v1::CreateTodoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::Todo>>(PrepareAsyncCreateTodoRaw(context, request, cq));
    }
    // Retrieves a todo item by resource name.
    virtual ::grpc::Status GetTodo(::grpc::ClientContext* context, const ::todo::v1::GetTodoRequest& request, ::todo::v1::Todo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::Todo>> AsyncGetTodo(::grpc::ClientContext* context, const ::todo::v1::GetTodoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::Todo>>(AsyncGetTodoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::Todo>> PrepareAsyncGetTodo(::grpc::ClientContext* context, const ::todo::v1::GetTodoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::Todo>>(PrepareAsyncGetTodoRaw(context, request, cq));
    }
    // Lists todo items with optional filtering.
    virtual ::grpc::Status ListTodos(::grpc::ClientContext* context, const ::todo::v1::ListTodosRequest& request, ::todo::v1::ListTodosResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::ListTodosResponse>> AsyncListTodos(::grpc::ClientContext* context, const ::todo::v1::ListTodosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::ListTodosResponse>>(AsyncListTodosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::ListTodosResponse>> PrepareAsyncListTodos(::grpc::ClientContext* context, const ::todo::v1::ListTodosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::ListTodosResponse>>(PrepareAsyncListTodosRaw(context, request, cq));
    }
    // Updates an existing todo item.
    virtual ::grpc::Status UpdateTodo(::grpc::ClientContext* context, const ::todo::v1::UpdateTodoRequest& request, ::todo::v1::Todo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::Todo>> AsyncUpdateTodo(::grpc::ClientContext* context, const ::todo::v1::UpdateTodoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::Todo>>(AsyncUpdateTodoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::Todo>> PrepareAsyncUpdateTodo(::grpc::ClientContext* context, const ::todo::v1::UpdateTodoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::Todo>>(PrepareAsyncUpdateTodoRaw(context, request, cq));
    }
    // Deletes a todo item by resource name.
    virtual ::grpc::Status DeleteTodo(::grpc::ClientContext* context, const ::todo::v1::DeleteTodoRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncDeleteTodo(::grpc::ClientContext* context, const ::todo::v1::DeleteTodoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncDeleteTodoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncDeleteTodo(::grpc::ClientContext* context, const ::todo::v1::DeleteTodoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncDeleteTodoRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Creates a new todo item.
      virtual void CreateTodo(::grpc::ClientContext* context, const ::todo::v1::CreateTodoRequest* request, ::todo::v1::Todo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateTodo(::grpc::ClientContext* context, const ::todo::v1::CreateTodoRequest* request, ::todo::v1::Todo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Retrieves a todo item by resource name.
      virtual void GetTodo(::grpc::ClientContext* context, const ::todo::v1::GetTodoRequest* request, ::todo::v1::Todo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTodo(::grpc::ClientContext* context, const ::todo::v1::GetTodoRequest* request, ::todo::v1::Todo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Lists todo items with optional filtering.
      virtual void ListTodos(::grpc::ClientContext* context, const ::todo::v1::ListTodosRequest* request, ::todo::v1::ListTodosResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListTodos(::grpc::ClientContext* context, const ::todo::v1::ListTodosRequest* request, ::todo::v1::ListTodosResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Updates an existing todo item.
      virtual void UpdateTodo(::grpc::ClientContext* context, const ::todo::v1::UpdateTodoRequest* request, ::todo::v1::Todo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateTodo(::grpc::ClientContext* context, const ::todo::v1::UpdateTodoRequest* request, ::todo::v1::Todo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Deletes a todo item by resource name.
      virtual void DeleteTodo(::grpc::ClientContext* context, const ::todo::v1::DeleteTodoRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteTodo(::grpc::ClientContext* context, const ::todo::v1::DeleteTodoRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::Todo>* AsyncCreateTodoRaw(::grpc::ClientContext* context, const ::todo::v1::CreateTodoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::Todo>* PrepareAsyncCreateTodoRaw(::grpc::ClientContext* context, const ::todo::v1::CreateTodoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::Todo>* AsyncGetTodoRaw(::grpc::ClientContext* context, const ::todo::v1::GetTodoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::Todo>* PrepareAsyncGetTodoRaw(::grpc::ClientContext* context, const ::todo::v1::GetTodoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::ListTodosResponse>* AsyncListTodosRaw(::grpc::ClientContext* context, const ::todo::v1::ListTodosRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::ListTodosResponse>* PrepareAsyncListTodosRaw(::grpc::ClientContext* context, const ::todo::v1::ListTodosRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::Todo>* AsyncUpdateTodoRaw(::grpc::ClientContext* context, const ::todo::v1::UpdateTodoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::todo::v1::Todo>* PrepareAsyncUpdateTodoRaw(::grpc::ClientContext* context, const ::todo::v1::UpdateTodoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncDeleteTodoRaw(::grpc::ClientContext* context, const ::todo::v1::DeleteTodoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncDeleteTodoRaw(::grpc::ClientContext* context, const ::todo::v1::DeleteTodoRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status CreateTodo(::grpc::ClientContext* context, const ::todo::v1::CreateTodoRequest& request, ::todo::v1::Todo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::todo::v1::Todo>> AsyncCreateTodo(::grpc::ClientContext* context, const ::todo::v1::CreateTodoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::todo::v1::Todo>>(AsyncCreateTodoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::todo::v1::Todo>> PrepareAsyncCreateTodo(::grpc::ClientContext* context, const ::todo::v1::CreateTodoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::todo::v1::Todo>>(PrepareAsyncCreateTodoRaw(context, request, cq));
    }
    ::grpc::Status GetTodo(::grpc::ClientContext* context, const ::todo::v1::GetTodoRequest& request, ::todo::v1::Todo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::todo::v1::Todo>> AsyncGetTodo(::grpc::ClientContext* context, const ::todo::v1::GetTodoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::todo::v1::Todo>>(AsyncGetTodoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::todo::v1::Todo>> PrepareAsyncGetTodo(::grpc::ClientContext* context, const ::todo::v1::GetTodoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::todo::v1::Todo>>(PrepareAsyncGetTodoRaw(context, request, cq));
    }
    ::grpc::Status ListTodos(::grpc::ClientContext* context, const ::todo::v1::ListTodosRequest& request, ::todo::v1::ListTodosResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::todo::v1::ListTodosResponse>> AsyncListTodos(::grpc::ClientContext* context, const ::todo::v1::ListTodosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::todo::v1::ListTodosResponse>>(AsyncListTodosRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::todo::v1::ListTodosResponse>> PrepareAsyncListTodos(::grpc::ClientContext* context, const ::todo::v1::ListTodosRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::todo::v1::ListTodosResponse>>(PrepareAsyncListTodosRaw(context, request, cq));
    }
    ::grpc::Status UpdateTodo(::grpc::ClientContext* context, const ::todo::v1::UpdateTodoRequest& request, ::todo::v1::Todo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::todo::v1::Todo>> AsyncUpdateTodo(::grpc::ClientContext* context, const ::todo::v1::UpdateTodoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::todo::v1::Todo>>(AsyncUpdateTodoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::todo::v1::Todo>> PrepareAsyncUpdateTodo(::grpc::ClientContext* context, const ::todo::v1::UpdateTodoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::todo::v1::Todo>>(PrepareAsyncUpdateTodoRaw(context, request, cq));
    }
    ::grpc::Status DeleteTodo(::grpc::ClientContext* context, const ::todo::v1::DeleteTodoRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncDeleteTodo(::grpc::ClientContext* context, const ::todo::v1::DeleteTodoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncDeleteTodoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncDeleteTodo(::grpc::ClientContext* context, const ::todo::v1::DeleteTodoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncDeleteTodoRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void CreateTodo(::grpc::ClientContext* context, const ::todo::v1::CreateTodoRequest* request, ::todo::v1::Todo* response, std::function<void(::grpc::Status)>) override;
      void CreateTodo(::grpc::ClientContext* context, const ::todo::v1::CreateTodoRequest* request, ::todo::v1::Todo* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTodo(::grpc::ClientContext* context, const ::todo::v1::GetTodoRequest* request, ::todo::v1::Todo* response, std::function<void(::grpc::Status)>) override;
      void GetTodo(::grpc::ClientContext* context, const ::todo::v1::GetTodoRequest* request, ::todo::v1::Todo* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListTodos(::grpc::ClientContext* context, const ::todo::v1::ListTodosRequest* request, ::todo::v1::ListTodosResponse* response, std::function<void(::grpc::Status)>) override;
      void ListTodos(::grpc::ClientContext* context, const ::todo::v1::ListTodosRequest* request, ::todo::v1::ListTodosResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UpdateTodo(::grpc::ClientContext* context, const ::todo::v1::UpdateTodoRequest* request, ::todo::v1::Todo* response, std::function<void(::grpc::Status)>) override;
      void UpdateTodo(::grpc::ClientContext* context, const ::todo::v1::UpdateTodoRequest* request, ::todo::v1::Todo* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DeleteTodo(::grpc::ClientContext* context, const ::todo::v1::DeleteTodoRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void DeleteTodo(::grpc::ClientContext* context, const ::todo::v1::DeleteTodoRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::todo::v1::Todo>* AsyncCreateTodoRaw(::grpc::ClientContext* context, const ::todo::v1::CreateTodoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::todo::v1::Todo>* PrepareAsyncCreateTodoRaw(::grpc::ClientContext* context, const ::todo::v1::CreateTodoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::todo::v1::Todo>* AsyncGetTodoRaw(::grpc::ClientContext* context, const ::todo::v1::GetTodoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::todo::v1::Todo>* PrepareAsyncGetTodoRaw(::grpc::ClientContext* context, const ::todo::v1::GetTodoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::todo::v1::ListTodosResponse>* AsyncListTodosRaw(::grpc::ClientContext* context, const ::todo::v1::ListTodosRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::todo::v1::ListTodosResponse>* PrepareAsyncListTodosRaw(::grpc::ClientContext* context, const ::todo::v1::ListTodosRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::todo::v1::Todo>* AsyncUpdateTodoRaw(::grpc::ClientContext* context, const ::todo::v1::UpdateTodoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::todo::v1::Todo>* PrepareAsyncUpdateTodoRaw(::grpc::ClientContext* context, const ::todo::v1::UpdateTodoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncDeleteTodoRaw(::grpc::ClientContext* context, const ::todo::v1::DeleteTodoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncDeleteTodoRaw(::grpc::ClientContext* context, const ::todo::v1::DeleteTodoRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_CreateTodo_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTodo_;
    const ::grpc::internal::RpcMethod rpcmethod_ListTodos_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateTodo_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteTodo_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Creates a new todo item.
    virtual ::grpc::Status CreateTodo(::grpc::ServerContext* context, const ::todo::v1::CreateTodoRequest* request, ::todo::v1::Todo* response);
    // Retrieves a todo item by resource name.
    virtual ::grpc::Status GetTodo(::grpc::ServerContext* context, const ::todo::v1::GetTodoRequest* request, ::todo::v1::Todo* response);
    // Lists todo items with optional filtering.
    virtual ::grpc::Status ListTodos(::grpc::ServerContext* context, const ::todo::v1::ListTodosRequest* request, ::todo::v1::ListTodosResponse* response);
    // Updates an existing todo item.
    virtual ::grpc::Status UpdateTodo(::grpc::ServerContext* context, const ::todo::v1::UpdateTodoRequest* request, ::todo::v1::Todo* response);
    // Deletes a todo item by resource name.
    virtual ::grpc::Status DeleteTodo(::grpc::ServerContext* context, const ::todo::v1::DeleteTodoRequest* request, ::google::protobuf::Empty* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateTodo() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_CreateTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::CreateTodoRequest* /*request*/, ::todo::v1::Todo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateTodo(::grpc::ServerContext* context, ::todo::v1::CreateTodoRequest* request, ::grpc::ServerAsyncResponseWriter< ::todo::v1::Todo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTodo() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::GetTodoRequest* /*request*/, ::todo::v1::Todo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTodo(::grpc::ServerContext* context, ::todo::v1::GetTodoRequest* request, ::grpc::ServerAsyncResponseWriter< ::todo::v1::Todo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListTodos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListTodos() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_ListTodos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTodos(::grpc::ServerContext* /*context*/, const ::todo::v1::ListTodosRequest* /*request*/, ::todo::v1::ListTodosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListTodos(::grpc::ServerContext* context, ::todo::v1::ListTodosRequest* request, ::grpc::ServerAsyncResponseWriter< ::todo::v1::ListTodosResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateTodo() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_UpdateTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::UpdateTodoRequest* /*request*/, ::todo::v1::Todo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateTodo(::grpc::ServerContext* context, ::todo::v1::UpdateTodoRequest* request, ::grpc::ServerAsyncResponseWriter< ::todo::v1::Todo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteTodo() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_DeleteTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::DeleteTodoRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteTodo(::grpc::ServerContext* context, ::todo::v1::DeleteTodoRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_CreateTodo<WithAsyncMethod_GetTodo<WithAsyncMethod_ListTodos<WithAsyncMethod_UpdateTodo<WithAsyncMethod_DeleteTodo<Service > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_CreateTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreateTodo() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::todo::v1::CreateTodoRequest, ::todo::v1::Todo>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::todo::v1::CreateTodoRequest* request, ::todo::v1::Todo* response) { return this->CreateTodo(context, request, response); }));}
    void SetMessageAllocatorFor_CreateTodo(
        ::grpc::MessageAllocator< ::todo::v1::CreateTodoRequest, ::todo::v1::Todo>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::todo::v1::CreateTodoRequest, ::todo::v1::Todo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreateTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::CreateTodoRequest* /*request*/, ::todo::v1::Todo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateTodo(
      ::grpc::CallbackServerContext* /*context*/, const ::todo::v1::CreateTodoRequest* /*request*/, ::todo::v1::Todo* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTodo() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::todo::v1::GetTodoRequest, ::todo::v1::Todo>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::todo::v1::GetTodoRequest* request, ::todo::v1::Todo* response) { return this->GetTodo(context, request, response); }));}
    void SetMessageAllocatorFor_GetTodo(
        ::grpc::MessageAllocator< ::todo::v1::GetTodoRequest, ::todo::v1::Todo>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::todo::v1::GetTodoRequest, ::todo::v1::Todo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::GetTodoRequest* /*request*/, ::todo::v1::Todo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTodo(
      ::grpc::CallbackServerContext* /*context*/, const ::todo::v1::GetTodoRequest* /*request*/, ::todo::v1::Todo* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListTodos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListTodos() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::todo::v1::ListTodosRequest, ::todo::v1::ListTodosResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::todo::v1::ListTodosRequest* request, ::todo::v1::ListTodosResponse* response) { return this->ListTodos(context, request, response); }));}
    void SetMessageAllocatorFor_ListTodos(
        ::grpc::MessageAllocator< ::todo::v1::ListTodosRequest, ::todo::v1::ListTodosResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::todo::v1::ListTodosRequest, ::todo::v1::ListTodosResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListTodos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTodos(::grpc::ServerContext* /*context*/, const ::todo::v1::ListTodosRequest* /*request*/, ::todo::v1::ListTodosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListTodos(
      ::grpc::CallbackServerContext* /*context*/, const ::todo::v1::ListTodosRequest* /*request*/, ::todo::v1::ListTodosResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UpdateTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UpdateTodo() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::todo::v1::UpdateTodoRequest, ::todo::v1::Todo>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::todo::v1::UpdateTodoRequest* request, ::todo::v1::Todo* response) { return this->UpdateTodo(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateTodo(
        ::grpc::MessageAllocator< ::todo::v1::UpdateTodoRequest, ::todo::v1::Todo>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::todo::v1::UpdateTodoRequest, ::todo::v1::Todo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UpdateTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::UpdateTodoRequest* /*request*/, ::todo::v1::Todo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateTodo(
      ::grpc::CallbackServerContext* /*context*/, const ::todo::v1::UpdateTodoRequest* /*request*/, ::todo::v1::Todo* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DeleteTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DeleteTodo() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::todo::v1::DeleteTodoRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::todo::v1::DeleteTodoRequest* request, ::google::protobuf::Empty* response) { return this->DeleteTodo(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteTodo(
        ::grpc::MessageAllocator< ::todo::v1::DeleteTodoRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::todo::v1::DeleteTodoRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DeleteTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::DeleteTodoRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteTodo(
      ::grpc::CallbackServerContext* /*context*/, const ::todo::v1::DeleteTodoRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_CreateTodo<WithCallbackMethod_GetTodo<WithCallbackMethod_ListTodos<WithCallbackMethod_UpdateTodo<WithCallbackMethod_DeleteTodo<Service > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_CreateTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateTodo() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_CreateTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::CreateTodoRequest* /*request*/, ::todo::v1::Todo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTodo() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::GetTodoRequest* /*request*/, ::todo::v1::Todo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListTodos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListTodos() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_ListTodos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTodos(::grpc::ServerContext* /*context*/, const ::todo::v1::ListTodosRequest* /*request*/, ::todo::v1::ListTodosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateTodo() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_UpdateTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::UpdateTodoRequest* /*request*/, ::todo::v1::Todo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteTodo() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_DeleteTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::DeleteTodoRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateTodo() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_CreateTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::CreateTodoRequest* /*request*/, ::todo::v1::Todo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateTodo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTodo() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::GetTodoRequest* /*request*/, ::todo::v1::Todo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTodo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListTodos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListTodos() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_ListTodos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTodos(::grpc::ServerContext* /*context*/, const ::todo::v1::ListTodosRequest* /*request*/, ::todo::v1::ListTodosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListTodos(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateTodo() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_UpdateTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::UpdateTodoRequest* /*request*/, ::todo::v1::Todo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateTodo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteTodo() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_DeleteTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::DeleteTodoRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteTodo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreateTodo() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateTodo(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreateTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::CreateTodoRequest* /*request*/, ::todo::v1::Todo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateTodo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTodo() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTodo(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::GetTodoRequest* /*request*/, ::todo::v1::Todo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTodo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListTodos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListTodos() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListTodos(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListTodos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTodos(::grpc::ServerContext* /*context*/, const ::todo::v1::ListTodosRequest* /*request*/, ::todo::v1::ListTodosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListTodos(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UpdateTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UpdateTodo() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateTodo(context, request, response); }));
    }
    ~WithRawCallbackMethod_UpdateTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::UpdateTodoRequest* /*request*/, ::todo::v1::Todo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateTodo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DeleteTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DeleteTodo() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteTodo(context, request, response); }));
    }
    ~WithRawCallbackMethod_DeleteTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::DeleteTodoRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteTodo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateTodo() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::todo::v1::CreateTodoRequest, ::todo::v1::Todo>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::todo::v1::CreateTodoRequest, ::todo::v1::Todo>* streamer) {
                       return this->StreamedCreateTodo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::CreateTodoRequest* /*request*/, ::todo::v1::Todo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateTodo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::todo::v1::CreateTodoRequest,::todo::v1::Todo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTodo() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::todo::v1::GetTodoRequest, ::todo::v1::Todo>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::todo::v1::GetTodoRequest, ::todo::v1::Todo>* streamer) {
                       return this->StreamedGetTodo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::GetTodoRequest* /*request*/, ::todo::v1::Todo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTodo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::todo::v1::GetTodoRequest,::todo::v1::Todo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListTodos : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListTodos() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::todo::v1::ListTodosRequest, ::todo::v1::ListTodosResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::todo::v1::ListTodosRequest, ::todo::v1::ListTodosResponse>* streamer) {
                       return this->StreamedListTodos(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListTodos() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListTodos(::grpc::ServerContext* /*context*/, const ::todo::v1::ListTodosRequest* /*request*/, ::todo::v1::ListTodosResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListTodos(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::todo::v1::ListTodosRequest,::todo::v1::ListTodosResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateTodo() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::todo::v1::UpdateTodoRequest, ::todo::v1::Todo>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::todo::v1::UpdateTodoRequest, ::todo::v1::Todo>* streamer) {
                       return this->StreamedUpdateTodo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::UpdateTodoRequest* /*request*/, ::todo::v1::Todo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateTodo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::todo::v1::UpdateTodoRequest,::todo::v1::Todo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteTodo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteTodo() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::todo::v1::DeleteTodoRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::todo::v1::DeleteTodoRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedDeleteTodo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteTodo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteTodo(::grpc::ServerContext* /*context*/, const ::todo::v1::DeleteTodoRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteTodo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::todo::v1::DeleteTodoRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CreateTodo<WithStreamedUnaryMethod_GetTodo<WithStreamedUnaryMethod_ListTodos<WithStreamedUnaryMethod_UpdateTodo<WithStreamedUnaryMethod_DeleteTodo<Service > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_CreateTodo<WithStreamedUnaryMethod_GetTodo<WithStreamedUnaryMethod_ListTodos<WithStreamedUnaryMethod_UpdateTodo<WithStreamedUnaryMethod_DeleteTodo<Service > > > > > StreamedService;
};

}  // namespace v1
}  // namespace todo


#include <grpcpp/ports_undef.inc>
#endif  // GRPC_todo_2fv1_2ftodo_5fservice_2eproto__INCLUDED
