# Code generated by protoc-gen-mcp. DO NOT EDIT.
# versions:
# 	protoc-gen-mcp v1.2.3+dirty
# Authors: Machani Robotics - Open Source 2026
# source: todo/v1/todo_service.proto

from __future__ import annotations

import json
from typing import Any, Protocol

import mcp.types as types
from mcp.server.fastmcp import FastMCP
from mcp.server.lowlevel import Server
from google.protobuf.json_format import MessageToDict, ParseDict

import todo.v1.todo_pb2
import google.protobuf.empty_pb2
TodoService_CreateTodo_SCHEMA = json.loads(r'''{"properties":{"parent":{"type":"string"},"todo":{"properties":{"completed":{"type":"boolean"},"create_time":{"format":"date-time","type":["string","null"]},"description":{"type":"string"},"name":{"type":"string"},"priority":{"enum":["PRIORITY_UNSPECIFIED","PRIORITY_LOW","PRIORITY_MEDIUM","PRIORITY_HIGH","PRIORITY_URGENT"],"type":"string"},"title":{"type":"string"},"update_time":{"format":"date-time","type":["string","null"]}},"required":[],"type":"object"},"todo_id":{"type":"string"}},"required":["parent","todo","todo_id"],"type":"object"}''')
TodoService_DeleteTodo_SCHEMA = json.loads(r'''{"properties":{"name":{"type":"string"}},"required":["name"],"type":"object"}''')
TodoService_GetTodo_SCHEMA = json.loads(r'''{"properties":{"name":{"type":"string"}},"required":["name"],"type":"object"}''')
TodoService_ListTodos_SCHEMA = json.loads(r'''{"properties":{"page_size":{"type":"integer"},"page_token":{"type":"string"},"parent":{"type":"string"}},"required":["parent"],"type":"object"}''')
TodoService_UpdateTodo_SCHEMA = json.loads(r'''{"properties":{"todo":{"properties":{"completed":{"type":"boolean"},"create_time":{"format":"date-time","type":["string","null"]},"description":{"type":"string"},"name":{"type":"string"},"priority":{"enum":["PRIORITY_UNSPECIFIED","PRIORITY_LOW","PRIORITY_MEDIUM","PRIORITY_HIGH","PRIORITY_URGENT"],"type":"string"},"title":{"type":"string"},"update_time":{"format":"date-time","type":["string","null"]}},"required":[],"type":"object"},"update_mask":{"type":"string"}},"required":["todo"],"type":"object"}''')


TodoService_CreateTodo_TOOL = types.Tool(
    name="todo_service-create_todo_v1",
    description="Creates a new todo item under a user. Requires parent (e.g. users/alice), a todo object with title/description/priority, and a unique todo_id.",
    inputSchema=TodoService_CreateTodo_SCHEMA,
)

TodoService_DeleteTodo_TOOL = types.Tool(
    name="todo_service-delete_todo_v1",
    description="Permanently deletes a todo item by its resource name. This action cannot be undone.",
    inputSchema=TodoService_DeleteTodo_SCHEMA,
)

TodoService_GetTodo_TOOL = types.Tool(
    name="todo_service-get_todo_v1",
    description="Retrieves a single todo item by its resource name (e.g. users/alice/todos/abc123).",
    inputSchema=TodoService_GetTodo_SCHEMA,
)

TodoService_ListTodos_TOOL = types.Tool(
    name="todo_service-list_todos_v1",
    description="Lists all todo items for a user. Supports pagination via page_size and page_token.",
    inputSchema=TodoService_ListTodos_SCHEMA,
)

TodoService_UpdateTodo_TOOL = types.Tool(
    name="todo_service-update_todo_v1",
    description="Updates an existing todo item. Send the todo with its resource name and the fields to update. Use update_mask to specify which fields to modify.",
    inputSchema=TodoService_UpdateTodo_SCHEMA,
)


class TodoServiceMCPServer(Protocol):
    """Protocol that users implement to handle MCP tool calls backed by TodoService RPCs."""
    async def create_todo(self, request: todo.v1.todo_pb2.CreateTodoRequest) -> todo.v1.todo_pb2.Todo: ...
    async def delete_todo(self, request: todo.v1.todo_pb2.DeleteTodoRequest) -> google.protobuf.empty_pb2.Empty: ...
    async def get_todo(self, request: todo.v1.todo_pb2.GetTodoRequest) -> todo.v1.todo_pb2.Todo: ...
    async def list_todos(self, request: todo.v1.todo_pb2.ListTodosRequest) -> todo.v1.todo_pb2.ListTodosResponse: ...
    async def update_todo(self, request: todo.v1.todo_pb2.UpdateTodoRequest) -> todo.v1.todo_pb2.Todo: ...

class TodoServiceMCPClient(Protocol):
    """gRPC client protocol used when forwarding MCP tool calls to a remote server."""
    async def create_todo(self, request: todo.v1.todo_pb2.CreateTodoRequest) -> todo.v1.todo_pb2.Todo: ...
    async def delete_todo(self, request: todo.v1.todo_pb2.DeleteTodoRequest) -> google.protobuf.empty_pb2.Empty: ...
    async def get_todo(self, request: todo.v1.todo_pb2.GetTodoRequest) -> todo.v1.todo_pb2.Todo: ...
    async def list_todos(self, request: todo.v1.todo_pb2.ListTodosRequest) -> todo.v1.todo_pb2.ListTodosResponse: ...
    async def update_todo(self, request: todo.v1.todo_pb2.UpdateTodoRequest) -> todo.v1.todo_pb2.Todo: ...

TodoService_MCP_DEFAULT_BASE_PATH = "/todo/v1/todoservice/mcp"

_ALL_TOOLS: list[types.Tool] = [
    TodoService_CreateTodo_TOOL,
    TodoService_DeleteTodo_TOOL,
    TodoService_GetTodo_TOOL,
    TodoService_ListTodos_TOOL,
    TodoService_UpdateTodo_TOOL,
]

def _todo_service_prompts() -> list[types.Prompt]:
    """Build the list of prompt descriptors for TodoService."""
    return [
        types.Prompt(
            name="summarize_todos",
            description="Summarize all pending todo items for a user",
            arguments=[
                types.PromptArgument(name="user", description="The user ID to summarize todos for.", required=True),
            ],
        ),
        types.Prompt(
            name="prioritize_todos",
            description="Suggest a priority ordering for a user's incomplete todos",
            arguments=[
                types.PromptArgument(name="user", description="The user ID whose todos to prioritize.", required=True),
                types.PromptArgument(name="strategy", description="Prioritization strategy.", required=False),
            ],
        ),
    ]

def _todo_service_resources() -> list[types.Resource | types.ResourceTemplate]:
    """Build the list of resource descriptors for TodoService."""
    return [
        types.ResourceTemplate(uriTemplate="todo://users/{user}/todos/{todo}", name="Todo", description="Todo resource (users/{user}/todos/{todo})", mimeType="application/json"),
    ]

def _todo_service_completion_map() -> dict[str, list[str]]:
    """Build a map of 'promptName:argName' -> allowed values from enum_values."""
    m: dict[str, list[str]] = {}
    m["prioritize_todos:strategy"] = ["urgency", "deadline", "effort", ]
    return m

def register_todo_service_mcp_handler(server: Server, impl: TodoServiceMCPServer) -> None:
    """Register all TodoService tools, prompts, and resources on the given MCP server."""

    @server.list_tools()
    async def handle_list_tools() -> list[types.Tool]:
        return _ALL_TOOLS

    @server.call_tool()
    async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[types.TextContent]:
        if name == "todo_service-create_todo_v1":
            try:
                _elicit_result = await server.request_context.session.elicit(
                    message="Please confirm the todo details before creating.",
                    requestedSchema={
                        "type": "object",
                        "properties": {
                            "confirm": {"type": "string", "description": "Confirm creation.", "enum": ["yes", "no", ]},
                        },
                        "required": ["confirm", ],
                    },
                )
                if _elicit_result.action != "accept":
                    return [types.TextContent(type="text", text="Action cancelled by user.")]
            except Exception:
                pass  # Client does not support elicitation; proceed with tool call.
            req = ParseDict(arguments, todo.v1.todo_pb2.CreateTodoRequest())
            resp = await impl.create_todo(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
        if name == "todo_service-delete_todo_v1":
            try:
                _elicit_result = await server.request_context.session.elicit(
                    message="Are you sure you want to delete this todo? This action cannot be undone.",
                    requestedSchema={
                        "type": "object",
                        "properties": {
                            "confirm": {"type": "string", "description": "Confirm deletion.", "enum": ["yes", "no", ]},
                        },
                        "required": ["confirm", ],
                    },
                )
                if _elicit_result.action != "accept":
                    return [types.TextContent(type="text", text="Action cancelled by user.")]
            except Exception:
                pass  # Client does not support elicitation; proceed with tool call.
            req = ParseDict(arguments, todo.v1.todo_pb2.DeleteTodoRequest())
            resp = await impl.delete_todo(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
        if name == "todo_service-get_todo_v1":
            req = ParseDict(arguments, todo.v1.todo_pb2.GetTodoRequest())
            resp = await impl.get_todo(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
        if name == "todo_service-list_todos_v1":
            req = ParseDict(arguments, todo.v1.todo_pb2.ListTodosRequest())
            resp = await impl.list_todos(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
        if name == "todo_service-update_todo_v1":
            try:
                _elicit_result = await server.request_context.session.elicit(
                    message="Please confirm the changes to this todo item.",
                    requestedSchema={
                        "type": "object",
                        "properties": {
                            "confirm": {"type": "string", "description": "Confirm update.", "enum": ["yes", "no", ]},
                        },
                        "required": ["confirm", ],
                    },
                )
                if _elicit_result.action != "accept":
                    return [types.TextContent(type="text", text="Action cancelled by user.")]
            except Exception:
                pass  # Client does not support elicitation; proceed with tool call.
            req = ParseDict(arguments, todo.v1.todo_pb2.UpdateTodoRequest())
            resp = await impl.update_todo(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
        raise ValueError(f"Unknown tool: {name}")

    _prompts = _todo_service_prompts()
    if _prompts:
        @server.list_prompts()
        async def handle_list_prompts() -> list[types.Prompt]:
            return _prompts

        @server.get_prompt()
        async def handle_get_prompt(name: str, arguments: dict[str, str] | None) -> types.GetPromptResult:
            for p in _prompts:
                if p.name == name:
                    arg_str = ", ".join(f"{k}={v}" for k, v in (arguments or {}).items())
                    return types.GetPromptResult(
                        description=p.description,
                        messages=[types.PromptMessage(role="user", content=types.TextContent(type="text", text=f"{p.description} ({arg_str})"))],
                    )
            raise ValueError(f"Unknown prompt: {name}")

    _resources = _todo_service_resources()
    if _resources:
        @server.list_resources()
        async def handle_list_resources() -> list[types.Resource]:
            return [r for r in _resources if isinstance(r, types.Resource)]

        @server.read_resource()
        async def handle_read_resource(uri: str) -> str:
            return "{}"

def serve_todo_service_mcp(
    impl: TodoServiceMCPServer,
    *,
    transport: str = "streamable-http",
    host: str = "0.0.0.0",
    port: int = 8080,
    path: str | None = None,
) -> None:
    """Create a FastMCP server, register TodoService tools, and start serving."""
    import contextlib, threading  # noqa: E401
    if path is None:
        path = TodoService_MCP_DEFAULT_BASE_PATH

    transports = [t.strip() for t in transport.split(",") if t.strip()]
    has_stdio = "stdio" in transports
    http_transports = [t for t in transports if t in ("sse", "streamable-http")]

    mcp_server = FastMCP("TodoService", json_response=True, streamable_http_path="/")
    register_todo_service_mcp_handler(mcp_server._mcp_server, impl)

    @contextlib.asynccontextmanager
    async def _lifespan(app):
        async with mcp_server.session_manager.run():
            yield

    if http_transports and has_stdio:
        def _run_http() -> None:
            import uvicorn
            from starlette.applications import Starlette
            from starlette.routing import Mount
            ht = http_transports[0]
            mcp_app = mcp_server.sse_app() if ht == "sse" else mcp_server.streamable_http_app()
            app = Starlette(routes=[Mount(path, app=mcp_app)], lifespan=_lifespan)
            cfg = uvicorn.Config(app, host=host, port=port, timeout_graceful_shutdown=0)
            uvicorn.Server(cfg).run()
        threading.Thread(target=_run_http, daemon=True).start()
        mcp_server.run(transport="stdio")
    elif http_transports:
        import uvicorn
        from starlette.applications import Starlette
        from starlette.routing import Mount, Route
        routes: list[Mount | Route] = []
        for ht in http_transports:
            mcp_app = mcp_server.sse_app() if ht == "sse" else mcp_server.streamable_http_app()
            routes.append(Mount(path if ht != "sse" else path, app=mcp_app))
        app = Starlette(routes=routes, lifespan=_lifespan)
        cfg = uvicorn.Config(app, host=host, port=port, timeout_graceful_shutdown=0)
        uvicorn.Server(cfg).run()
    elif has_stdio:
        mcp_server.run(transport="stdio")
    else:
        raise ValueError(f"Unsupported transport(s): {transport}")

def forward_to_todo_service_mcp_client(server: Server, client: TodoServiceMCPClient) -> None:
    """Register all TodoService tools on the MCP server, forwarding each call to a remote gRPC server."""

    @server.list_tools()
    async def handle_list_tools() -> list[types.Tool]:
        return _ALL_TOOLS

    @server.call_tool()
    async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[types.TextContent]:
        if name == "todo_service-create_todo_v1":
            try:
                _elicit_result = await server.request_context.session.elicit(
                    message="Please confirm the todo details before creating.",
                    requestedSchema={
                        "type": "object",
                        "properties": {
                            "confirm": {"type": "string", "description": "Confirm creation.", "enum": ["yes", "no", ]},
                        },
                        "required": ["confirm", ],
                    },
                )
                if _elicit_result.action != "accept":
                    return [types.TextContent(type="text", text="Action cancelled by user.")]
            except Exception:
                pass  # Client does not support elicitation; proceed with tool call.
            req = ParseDict(arguments, todo.v1.todo_pb2.CreateTodoRequest())
            resp = await client.create_todo(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
        if name == "todo_service-delete_todo_v1":
            try:
                _elicit_result = await server.request_context.session.elicit(
                    message="Are you sure you want to delete this todo? This action cannot be undone.",
                    requestedSchema={
                        "type": "object",
                        "properties": {
                            "confirm": {"type": "string", "description": "Confirm deletion.", "enum": ["yes", "no", ]},
                        },
                        "required": ["confirm", ],
                    },
                )
                if _elicit_result.action != "accept":
                    return [types.TextContent(type="text", text="Action cancelled by user.")]
            except Exception:
                pass  # Client does not support elicitation; proceed with tool call.
            req = ParseDict(arguments, todo.v1.todo_pb2.DeleteTodoRequest())
            resp = await client.delete_todo(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
        if name == "todo_service-get_todo_v1":
            req = ParseDict(arguments, todo.v1.todo_pb2.GetTodoRequest())
            resp = await client.get_todo(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
        if name == "todo_service-list_todos_v1":
            req = ParseDict(arguments, todo.v1.todo_pb2.ListTodosRequest())
            resp = await client.list_todos(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
        if name == "todo_service-update_todo_v1":
            try:
                _elicit_result = await server.request_context.session.elicit(
                    message="Please confirm the changes to this todo item.",
                    requestedSchema={
                        "type": "object",
                        "properties": {
                            "confirm": {"type": "string", "description": "Confirm update.", "enum": ["yes", "no", ]},
                        },
                        "required": ["confirm", ],
                    },
                )
                if _elicit_result.action != "accept":
                    return [types.TextContent(type="text", text="Action cancelled by user.")]
            except Exception:
                pass  # Client does not support elicitation; proceed with tool call.
            req = ParseDict(arguments, todo.v1.todo_pb2.UpdateTodoRequest())
            resp = await client.update_todo(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
        raise ValueError(f"Unknown tool: {name}")
