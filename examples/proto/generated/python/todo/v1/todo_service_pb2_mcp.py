# Code generated by protoc-gen-mcp. DO NOT EDIT.
# Open Source at Machani Robotics - https://github.com/machanirobotics/protoc-mcp-gen
# source: todo/v1/todo_service.proto

from __future__ import annotations

import json
from typing import Any, Protocol

import mcp.types as types
from mcp.server.fastmcp import FastMCP
from mcp.server.lowlevel import Server
from google.protobuf.json_format import MessageToDict, ParseDict

import todo.v1.todo_pb2
import google.protobuf.empty_pb2

# JSON schemas for each RPC method, used as the inputSchema for MCP tools.
TodoService_CreateTodo_SCHEMA = json.loads(r'''{"properties":{"parent":{"type":"string"},"todo":{"properties":{"completed":{"type":"boolean"},"create_time":{"format":"date-time","type":["string","null"]},"description":{"type":"string"},"name":{"type":"string"},"priority":{"enum":["PRIORITY_UNSPECIFIED","PRIORITY_LOW","PRIORITY_MEDIUM","PRIORITY_HIGH","PRIORITY_URGENT"],"type":"string"},"title":{"type":"string"},"update_time":{"format":"date-time","type":["string","null"]}},"required":[],"type":"object"},"todo_id":{"type":"string"}},"required":["parent","todo","todo_id"],"type":"object"}''')
TodoService_DeleteTodo_SCHEMA = json.loads(r'''{"properties":{"name":{"type":"string"}},"required":["name"],"type":"object"}''')
TodoService_GetTodo_SCHEMA = json.loads(r'''{"properties":{"name":{"type":"string"}},"required":["name"],"type":"object"}''')
TodoService_ListTodos_SCHEMA = json.loads(r'''{"properties":{"page_size":{"type":"integer"},"page_token":{"type":"string"},"parent":{"type":"string"}},"required":["parent"],"type":"object"}''')
TodoService_UpdateTodo_SCHEMA = json.loads(r'''{"properties":{"todo":{"properties":{"completed":{"type":"boolean"},"create_time":{"format":"date-time","type":["string","null"]},"description":{"type":"string"},"name":{"type":"string"},"priority":{"enum":["PRIORITY_UNSPECIFIED","PRIORITY_LOW","PRIORITY_MEDIUM","PRIORITY_HIGH","PRIORITY_URGENT"],"type":"string"},"title":{"type":"string"},"update_time":{"format":"date-time","type":["string","null"]}},"required":[],"type":"object"},"update_mask":{"type":"string"}},"required":["todo"],"type":"object"}''')

# MCP tool descriptors. Each pairs a schema with a tool name and description
# so that LLM clients can discover and invoke the underlying RPCs.

TodoService_CreateTodo_TOOL = types.Tool(
    name="todo_v1_TodoService_CreateTodo",
    description="Creates a new todo item.",
    inputSchema=TodoService_CreateTodo_SCHEMA,
)

TodoService_DeleteTodo_TOOL = types.Tool(
    name="todo_v1_TodoService_DeleteTodo",
    description="Deletes a todo item by resource name.",
    inputSchema=TodoService_DeleteTodo_SCHEMA,
)

TodoService_GetTodo_TOOL = types.Tool(
    name="todo_v1_TodoService_GetTodo",
    description="Retrieves a todo item by resource name.",
    inputSchema=TodoService_GetTodo_SCHEMA,
)

TodoService_ListTodos_TOOL = types.Tool(
    name="todo_v1_TodoService_ListTodos",
    description="Lists todo items with optional filtering.",
    inputSchema=TodoService_ListTodos_SCHEMA,
)

TodoService_UpdateTodo_TOOL = types.Tool(
    name="todo_v1_TodoService_UpdateTodo",
    description="Updates an existing todo item.",
    inputSchema=TodoService_UpdateTodo_SCHEMA,
)


# Protocol that users implement to handle MCP tool calls backed by
# TodoService RPCs. Each method mirrors a unary RPC from the service definition.
class TodoServiceMCPServer(Protocol):
    async def create_todo(self, request: todo.v1.todo_pb2.CreateTodoRequest) -> todo.v1.todo_pb2.Todo: ...
    async def delete_todo(self, request: todo.v1.todo_pb2.DeleteTodoRequest) -> google.protobuf.empty_pb2.Empty: ...
    async def get_todo(self, request: todo.v1.todo_pb2.GetTodoRequest) -> todo.v1.todo_pb2.Todo: ...
    async def list_todos(self, request: todo.v1.todo_pb2.ListTodosRequest) -> todo.v1.todo_pb2.ListTodosResponse: ...
    async def update_todo(self, request: todo.v1.todo_pb2.UpdateTodoRequest) -> todo.v1.todo_pb2.Todo: ...

# gRPC client protocol used when forwarding MCP tool calls to a remote server.
class TodoServiceMCPClient(Protocol):
    async def create_todo(self, request: todo.v1.todo_pb2.CreateTodoRequest) -> todo.v1.todo_pb2.Todo: ...
    async def delete_todo(self, request: todo.v1.todo_pb2.DeleteTodoRequest) -> google.protobuf.empty_pb2.Empty: ...
    async def get_todo(self, request: todo.v1.todo_pb2.GetTodoRequest) -> todo.v1.todo_pb2.Todo: ...
    async def list_todos(self, request: todo.v1.todo_pb2.ListTodosRequest) -> todo.v1.todo_pb2.ListTodosResponse: ...
    async def update_todo(self, request: todo.v1.todo_pb2.UpdateTodoRequest) -> todo.v1.todo_pb2.Todo: ...

# Default HTTP path prefix for TodoService MCP endpoints,
# derived from the protobuf package and service name.
TodoService_MCP_DEFAULT_BASE_PATH = "/todo/v1/todoservice/mcp"

# Flat list of every tool descriptor, returned by the list_tools handler.
_ALL_TOOLS: list[types.Tool] = [
    TodoService_CreateTodo_TOOL,
    TodoService_DeleteTodo_TOOL,
    TodoService_GetTodo_TOOL,
    TodoService_ListTodos_TOOL,
    TodoService_UpdateTodo_TOOL,
]

def register_todo_service_mcp_handler(server: Server, impl: TodoServiceMCPServer) -> None:
    """Register all TodoService tools on the given MCP server."""

    @server.list_tools()
    async def handle_list_tools() -> list[types.Tool]:
        return _ALL_TOOLS

    @server.call_tool()
    async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[types.TextContent]:
        if name == "todo_v1_TodoService_CreateTodo":
            req = ParseDict(arguments, todo.v1.todo_pb2.CreateTodoRequest())
            resp = await impl.create_todo(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
        if name == "todo_v1_TodoService_DeleteTodo":
            req = ParseDict(arguments, todo.v1.todo_pb2.DeleteTodoRequest())
            resp = await impl.delete_todo(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
        if name == "todo_v1_TodoService_GetTodo":
            req = ParseDict(arguments, todo.v1.todo_pb2.GetTodoRequest())
            resp = await impl.get_todo(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
        if name == "todo_v1_TodoService_ListTodos":
            req = ParseDict(arguments, todo.v1.todo_pb2.ListTodosRequest())
            resp = await impl.list_todos(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
        if name == "todo_v1_TodoService_UpdateTodo":
            req = ParseDict(arguments, todo.v1.todo_pb2.UpdateTodoRequest())
            resp = await impl.update_todo(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
        raise ValueError(f"Unknown tool: {name}")

def serve_todo_service_mcp(
    impl: TodoServiceMCPServer,
    *,
    transport: str = "streamable-http",
    host: str = "0.0.0.0",
    port: int = 8080,
    path: str | None = None,
) -> None:
    """Create a FastMCP server, register TodoService tools, and start serving.

    Supports multiple transports simultaneously via comma-separated values,
    e.g. ``transport="stdio,streamable-http"``.

    Args:
        impl: The service implementation.
        transport: Comma-separated list of "stdio", "sse", "streamable-http".
        host: Bind address for HTTP transports.
        port: Port for HTTP transports.
        path: Base path for HTTP transports (defaults to TodoService_MCP_DEFAULT_BASE_PATH).
    """
    import asyncio, contextlib, threading  # noqa: E401
    if path is None:
        path = TodoService_MCP_DEFAULT_BASE_PATH

    transports = [t.strip() for t in transport.split(",") if t.strip()]
    has_stdio = "stdio" in transports
    http_transports = [t for t in transports if t in ("sse", "streamable-http")]

    mcp_server = FastMCP("TodoService", json_response=True, streamable_http_path="/")
    register_todo_service_mcp_handler(mcp_server._mcp_server, impl)

    @contextlib.asynccontextmanager
    async def _lifespan(app):
        async with mcp_server.session_manager.run():
            yield

    if http_transports and has_stdio:
        # Run HTTP in a daemon thread, stdio in the main thread.
        def _run_http() -> None:
            import uvicorn
            from starlette.applications import Starlette
            from starlette.routing import Mount
            ht = http_transports[0]
            mcp_app = mcp_server.sse_app() if ht == "sse" else mcp_server.streamable_http_app()
            app = Starlette(routes=[Mount(path, app=mcp_app)], lifespan=_lifespan)
            cfg = uvicorn.Config(app, host=host, port=port, timeout_graceful_shutdown=0)
            uvicorn.Server(cfg).run()
        threading.Thread(target=_run_http, daemon=True).start()
        mcp_server.run(transport="stdio")
    elif http_transports:
        import uvicorn
        from starlette.applications import Starlette
        from starlette.routing import Mount, Route
        routes: list[Mount | Route] = []
        for ht in http_transports:
            mcp_app = mcp_server.sse_app() if ht == "sse" else mcp_server.streamable_http_app()
            routes.append(Mount(path if ht != "sse" else path, app=mcp_app))
        app = Starlette(routes=routes, lifespan=_lifespan)
        cfg = uvicorn.Config(app, host=host, port=port, timeout_graceful_shutdown=0)
        uvicorn.Server(cfg).run()
    elif has_stdio:
        mcp_server.run(transport="stdio")
    else:
        raise ValueError(f"Unsupported transport(s): {transport}")

def forward_to_todo_service_mcp_client(server: Server, client: TodoServiceMCPClient) -> None:
    """Register all TodoService tools on the MCP server, forwarding each call to a remote gRPC server via the provided client stub."""

    @server.list_tools()
    async def handle_list_tools() -> list[types.Tool]:
        return _ALL_TOOLS

    @server.call_tool()
    async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[types.TextContent]:
        if name == "todo_v1_TodoService_CreateTodo":
            req = ParseDict(arguments, todo.v1.todo_pb2.CreateTodoRequest())
            resp = await client.create_todo(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
        if name == "todo_v1_TodoService_DeleteTodo":
            req = ParseDict(arguments, todo.v1.todo_pb2.DeleteTodoRequest())
            resp = await client.delete_todo(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
        if name == "todo_v1_TodoService_GetTodo":
            req = ParseDict(arguments, todo.v1.todo_pb2.GetTodoRequest())
            resp = await client.get_todo(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
        if name == "todo_v1_TodoService_ListTodos":
            req = ParseDict(arguments, todo.v1.todo_pb2.ListTodosRequest())
            resp = await client.list_todos(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
        if name == "todo_v1_TodoService_UpdateTodo":
            req = ParseDict(arguments, todo.v1.todo_pb2.UpdateTodoRequest())
            resp = await client.update_todo(req)
            return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
        raise ValueError(f"Unknown tool: {name}")
