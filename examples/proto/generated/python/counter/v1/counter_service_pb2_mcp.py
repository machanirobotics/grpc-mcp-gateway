# Code generated by protoc-gen-mcp. DO NOT EDIT.
# versions:
# 	protoc-gen-mcp v1.3.4-0.20260225060520-7b3b28c62629+dirty
# Authors: Machani Robotics - Open Source 2026
# source: counter/v1/counter_service.proto

from __future__ import annotations

import json
from typing import Any, Protocol

import mcp.types as types
from mcp.server.fastmcp import FastMCP
from mcp.server.lowlevel import Server
from google.protobuf.json_format import MessageToDict, ParseDict





class CounterServiceMCPServer(Protocol):
    """Protocol that users implement to handle MCP tool calls backed by CounterService RPCs."""

class CounterServiceMCPClient(Protocol):
    """gRPC client protocol used when forwarding MCP tool calls to a remote server."""

CounterService_MCP_DEFAULT_BASE_PATH = "/counter/v1/counterservice/mcp"

_ALL_TOOLS: list[types.Tool] = [
]

def _counter_service_prompts() -> list[types.Prompt]:
    """Build the list of prompt descriptors for CounterService."""
    return [
    ]

def _counter_service_resources() -> list[types.Resource | types.ResourceTemplate]:
    """Build the list of resource descriptors for CounterService."""
    return [
    ]

def _counter_service_completion_map() -> dict[str, list[str]]:
    """Build a map of 'promptName:argName' -> allowed values from enum_values."""
    m: dict[str, list[str]] = {}
    return m

def register_counter_service_mcp_handler(server: Server, impl: CounterServiceMCPServer) -> None:
    """Register all CounterService tools, prompts, and resources on the given MCP server."""

    @server.list_tools()
    async def handle_list_tools() -> list[types.Tool]:
        return _ALL_TOOLS

    @server.call_tool()
    async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[types.TextContent]:
        raise ValueError(f"Unknown tool: {name}")

    _prompts = _counter_service_prompts()
    if _prompts:
        @server.list_prompts()
        async def handle_list_prompts() -> list[types.Prompt]:
            return _prompts

        @server.get_prompt()
        async def handle_get_prompt(name: str, arguments: dict[str, str] | None) -> types.GetPromptResult:
            for p in _prompts:
                if p.name == name:
                    arg_str = ", ".join(f"{k}={v}" for k, v in (arguments or {}).items())
                    return types.GetPromptResult(
                        description=p.description,
                        messages=[types.PromptMessage(role="user", content=types.TextContent(type="text", text=f"{p.description} ({arg_str})"))],
                    )
            raise ValueError(f"Unknown prompt: {name}")

    _resources = _counter_service_resources()
    if _resources:
        @server.list_resources()
        async def handle_list_resources() -> list[types.Resource]:
            return [r for r in _resources if isinstance(r, types.Resource)]

        @server.read_resource()
        async def handle_read_resource(uri: str) -> str:
            return "{}"

def serve_counter_service_mcp(
    impl: CounterServiceMCPServer,
    *,
    transport: str = "streamable-http",
    host: str = "0.0.0.0",
    port: int = 8080,
    path: str | None = None,
) -> None:
    """Create a FastMCP server, register CounterService tools, and start serving."""
    import contextlib, threading  # noqa: E401
    if path is None:
        path = CounterService_MCP_DEFAULT_BASE_PATH

    transports = [t.strip() for t in transport.split(",") if t.strip()]
    has_stdio = "stdio" in transports
    http_transports = [t for t in transports if t in ("sse", "streamable-http")]

    mcp_server = FastMCP("CounterService", json_response=True, streamable_http_path="/")
    register_counter_service_mcp_handler(mcp_server._mcp_server, impl)

    @contextlib.asynccontextmanager
    async def _lifespan(app):
        async with mcp_server.session_manager.run():
            yield

    if http_transports and has_stdio:
        def _run_http() -> None:
            import uvicorn
            from starlette.applications import Starlette
            from starlette.routing import Mount
            ht = http_transports[0]
            mcp_app = mcp_server.sse_app() if ht == "sse" else mcp_server.streamable_http_app()
            app = Starlette(routes=[Mount(path, app=mcp_app)], lifespan=_lifespan)
            cfg = uvicorn.Config(app, host=host, port=port, timeout_graceful_shutdown=0)
            uvicorn.Server(cfg).run()
        threading.Thread(target=_run_http, daemon=True).start()
        mcp_server.run(transport="stdio")
    elif http_transports:
        import uvicorn
        from starlette.applications import Starlette
        from starlette.routing import Mount, Route
        routes: list[Mount | Route] = []
        for ht in http_transports:
            mcp_app = mcp_server.sse_app() if ht == "sse" else mcp_server.streamable_http_app()
            routes.append(Mount(path if ht != "sse" else path, app=mcp_app))
        app = Starlette(routes=routes, lifespan=_lifespan)
        cfg = uvicorn.Config(app, host=host, port=port, timeout_graceful_shutdown=0)
        uvicorn.Server(cfg).run()
    elif has_stdio:
        mcp_server.run(transport="stdio")
    else:
        raise ValueError(f"Unsupported transport(s): {transport}")

def forward_to_counter_service_mcp_client(server: Server, client: CounterServiceMCPClient) -> None:
    """Register all CounterService tools on the MCP server, forwarding each call to a remote gRPC server."""

    @server.list_tools()
    async def handle_list_tools() -> list[types.Tool]:
        return _ALL_TOOLS

    @server.call_tool()
    async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[types.TextContent]:
        raise ValueError(f"Unknown tool: {name}")
