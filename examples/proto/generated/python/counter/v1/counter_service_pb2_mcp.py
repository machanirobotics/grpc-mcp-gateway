# Code generated by protoc-gen-mcp. DO NOT EDIT.
# versions:
# 	protoc-gen-mcp v1.4.1-0.20260226140831-4ca3558529bb+dirty
# Authors: Machani Robotics - Open Source 2026
# source: counter/v1/counter_service.proto

from __future__ import annotations

import json
from typing import Any, Iterator, Protocol

import mcp.types as types
from mcp.server.fastmcp import FastMCP
from mcp.server.lowlevel import Server
from google.protobuf.json_format import MessageToDict, ParseDict

import counter.v1.counter_service_pb2
import counter.v1.counter_pb2
CounterService_Count_SCHEMA = json.loads(r'''{"description":"Counts from 0 up to the given number. Sends progress updates as it counts. Use with progressToken in _meta for progress notifications.","properties":{"to":{"description":"Count from 0 up to this number. Progress updates are sent each step.","examples":["5","10"],"type":"integer"}},"required":[],"type":"object"}''')


CounterService_Count_TOOL = types.Tool(
    name="counter_service-count_v1",
    description="Counts from 0 up to the given number. Sends progress updates as it counts. Use with progressToken in _meta for progress notifications.",
    inputSchema=CounterService_Count_SCHEMA,
)


class CounterServiceMCPServer(Protocol):
    """Protocol that users implement to handle MCP tool calls backed by CounterService RPCs.
    Server-streaming RPCs (with progress) are only supported via forward_to_counter_service_mcp_client."""

class CounterServiceMCPClient(Protocol):
    """gRPC client protocol used when forwarding MCP tool calls to a remote server."""
    def count(self, request: counter.v1.counter_pb2.CountRequest) -> Iterator[counter.v1.counter_service_pb2.CountStreamChunk]: ...

CounterService_MCP_DEFAULT_BASE_PATH = "/counter/v1/counterservice/mcp"

_ALL_TOOLS: list[types.Tool] = [
    CounterService_Count_TOOL,
]

_STREAMING_TOOL_NAMES: frozenset[str] = frozenset({
    "counter_service-count_v1",
})

def _counter_service_prompts() -> list[types.Prompt]:
    """Build the list of prompt descriptors for CounterService."""
    return [
    ]

def _counter_service_resources() -> list[types.Resource | types.ResourceTemplate]:
    """Build the list of resource descriptors for CounterService."""
    return [
    ]

def _counter_service_completion_map() -> dict[str, list[str]]:
    """Build a map of 'promptName:argName' -> allowed values from enum_values."""
    m: dict[str, list[str]] = {}
    return m

def register_counter_service_mcp_handler(server: Server, impl: CounterServiceMCPServer) -> None:
    """Register all CounterService tools, prompts, and resources on the given MCP server."""

    @server.list_tools()
    async def handle_list_tools() -> list[types.Tool]:
        return [t for t in _ALL_TOOLS if t.name not in _STREAMING_TOOL_NAMES]

    @server.call_tool()
    async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[types.TextContent]:
        raise ValueError(f"Unknown tool: {name}")

    _prompts = _counter_service_prompts()
    if _prompts:
        @server.list_prompts()
        async def handle_list_prompts() -> list[types.Prompt]:
            return _prompts

        @server.get_prompt()
        async def handle_get_prompt(name: str, arguments: dict[str, str] | None) -> types.GetPromptResult:
            for p in _prompts:
                if p.name == name:
                    arg_str = ", ".join(f"{k}={v}" for k, v in (arguments or {}).items())
                    return types.GetPromptResult(
                        description=p.description,
                        messages=[types.PromptMessage(role="user", content=types.TextContent(type="text", text=f"{p.description} ({arg_str})"))],
                    )
            raise ValueError(f"Unknown prompt: {name}")

    _resources = _counter_service_resources()
    if _resources:
        @server.list_resources()
        async def handle_list_resources() -> list[types.Resource]:
            return [r for r in _resources if isinstance(r, types.Resource)]

        @server.read_resource()
        async def handle_read_resource(uri: str) -> str:
            return "{}"

def serve_counter_service_mcp(
    impl: CounterServiceMCPServer,
    *,
    transport: str = "streamable-http",
    host: str = "0.0.0.0",
    port: int = 8080,
    path: str | None = None,
) -> None:
    """Create a FastMCP server, register CounterService tools, and start serving."""
    import contextlib, threading  # noqa: E401
    if path is None:
        path = CounterService_MCP_DEFAULT_BASE_PATH

    transports = [t.strip() for t in transport.split(",") if t.strip()]
    has_stdio = "stdio" in transports
    http_transports = [t for t in transports if t in ("sse", "streamable-http")]

    mcp_server = FastMCP("CounterService", json_response=True, streamable_http_path="/")
    register_counter_service_mcp_handler(mcp_server._mcp_server, impl)

    @contextlib.asynccontextmanager
    async def _lifespan(app):
        async with mcp_server.session_manager.run():
            yield

    if http_transports and has_stdio:
        def _run_http() -> None:
            import uvicorn
            from starlette.applications import Starlette
            from starlette.routing import Mount
            ht = http_transports[0]
            mcp_app = mcp_server.sse_app() if ht == "sse" else mcp_server.streamable_http_app()
            app = Starlette(routes=[Mount(path, app=mcp_app)], lifespan=_lifespan)
            cfg = uvicorn.Config(app, host=host, port=port, timeout_graceful_shutdown=0)
            uvicorn.Server(cfg).run()
        threading.Thread(target=_run_http, daemon=True).start()
        mcp_server.run(transport="stdio")
    elif http_transports:
        import uvicorn
        from starlette.applications import Starlette
        from starlette.routing import Mount, Route
        routes: list[Mount | Route] = []
        for ht in http_transports:
            mcp_app = mcp_server.sse_app() if ht == "sse" else mcp_server.streamable_http_app()
            routes.append(Mount(path if ht != "sse" else path, app=mcp_app))
        app = Starlette(routes=routes, lifespan=_lifespan)
        cfg = uvicorn.Config(app, host=host, port=port, timeout_graceful_shutdown=0)
        uvicorn.Server(cfg).run()
    elif has_stdio:
        mcp_server.run(transport="stdio")
    else:
        raise ValueError(f"Unsupported transport(s): {transport}")

def forward_to_counter_service_mcp_client(server: Server, client: CounterServiceMCPClient) -> None:
    """Register all CounterService tools on the MCP server, forwarding each call to a remote gRPC server."""

    @server.list_tools()
    async def handle_list_tools() -> list[types.Tool]:
        return _ALL_TOOLS

    @server.call_tool()
    async def handle_call_tool(name: str, arguments: dict[str, Any]) -> list[types.TextContent]:
        if name == "counter_service-count_v1":
            req = ParseDict(arguments, counter.v1.counter_pb2.CountRequest())
            _progress_token = None
            try:
                _params = server.request_context.request.params
                if _params.meta is not None:
                    _progress_token = _params.meta.progressToken
            except Exception:
                pass
            stream = client.count(req)
            session = server.request_context.session
            for chunk in stream:
                if chunk.HasField("progress"):
                    _p = chunk.progress
                    if _progress_token is not None:
                        await session.send_progress_notification(
                            _progress_token,
                            progress=_p.progress,
                            total=_p.total if _p.HasField("total") else None,
                            message=_p.message or None,
                        )
                elif chunk.HasField("result"):
                    resp = chunk.result
                    return [types.TextContent(type="text", text=json.dumps(MessageToDict(resp, preserving_proto_field_name=True, always_print_fields_with_no_presence=True)))]
            raise ValueError("Stream ended without result")
        raise ValueError(f"Unknown tool: {name}")
