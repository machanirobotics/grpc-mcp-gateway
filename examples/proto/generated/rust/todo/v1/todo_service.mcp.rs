// Code generated by protoc-gen-mcp. DO NOT EDIT.
// versions:
// 	protoc-gen-mcp v1.3.4-0.20260225060520-7b3b28c62629+dirty
// Authors: Machani Robotics - Open Source 2026
// source: todo/v1/todo_service.proto

use std::sync::Arc;
use async_trait::async_trait;
use rmcp::{ErrorData as McpError, RoleServer, ServerHandler, ServiceExt, model::*, service::RequestContext};
use serde_json::{self, json, Value};

fn make_tool(name: &str, description: &str, schema_json: &str) -> Tool {
    serde_json::from_value(json!({
        "name": name, "description": description,
        "inputSchema": serde_json::from_str::<Value>(schema_json).unwrap(),
    })).expect("generated tool schema must be valid")
}

const TODO_SERVICE__CREATE_TODO_SCHEMA_JSON: &str = r##"{"description":"Creates a new todo item under a user. Requires parent (e.g. users/alice), a todo object with title/description/priority, and a unique todo_id.","properties":{"parent":{"description":"Parent resource name (e.g. users/alice). The todo will be created under this user.","type":"string"},"todo":{"properties":{"completed":{"description":"Whether the todo is done.","type":"boolean"},"create_time":{"format":"date-time","type":["string","null"]},"description":{"description":"Optional longer description or notes.","type":"string"},"name":{"description":"Resource name (e.g. users/alice/todos/abc123). Required when updating.","type":"string"},"priority":{"description":"Priority level for a todo item.. PRIORITY_UNSPECIFIED: Unspecified; use default priority.. PRIORITY_LOW: Low priority; can be done when convenient.. PRIORITY_MEDIUM: Normal priority; default for most todos.. PRIORITY_HIGH: High priority; should be done soon.. PRIORITY_URGENT: Urgent; do first.","enum":["PRIORITY_UNSPECIFIED","PRIORITY_LOW","PRIORITY_MEDIUM","PRIORITY_HIGH","PRIORITY_URGENT"],"enumDescriptions":{"PRIORITY_HIGH":"High priority; should be done soon.","PRIORITY_LOW":"Low priority; can be done when convenient.","PRIORITY_MEDIUM":"Normal priority; default for most todos.","PRIORITY_UNSPECIFIED":"Unspecified; use default priority.","PRIORITY_URGENT":"Urgent; do first."},"type":"string"},"title":{"description":"Short title for the todo.","type":"string"},"update_time":{"format":"date-time","type":["string","null"]}},"required":[],"type":"object"},"todo_id":{"description":"Unique ID for the todo (e.g. abc123). Becomes the final segment of the resource name.","examples":["abc123","todo-001"],"type":"string"}},"required":["parent","todo","todo_id"],"type":"object"}"##;
const TODO_SERVICE__DELETE_TODO_SCHEMA_JSON: &str = r##"{"description":"Permanently deletes a todo item by its resource name. This action cannot be undone.","properties":{"name":{"description":"Resource name of the todo to delete (e.g. users/alice/todos/abc123).","type":"string"}},"required":["name"],"type":"object"}"##;
const TODO_SERVICE__GET_TODO_SCHEMA_JSON: &str = r##"{"description":"Retrieves a single todo item by its resource name (e.g. users/alice/todos/abc123).","properties":{"name":{"description":"Resource name of the todo (e.g. users/alice/todos/abc123).","examples":["users/alice/todos/abc123"],"format":"uri","type":"string"}},"required":["name"],"type":"object"}"##;
const TODO_SERVICE__LIST_TODOS_SCHEMA_JSON: &str = r##"{"description":"Lists all todo items for a user. Supports pagination via page_size and page_token.","properties":{"page_size":{"description":"Max number of todos to return (default 50).","type":"integer"},"page_token":{"description":"Token from previous response for next page.","type":"string"},"parent":{"description":"Parent resource name (e.g. users/alice). Lists todos for this user.","type":"string"}},"required":["parent"],"type":"object"}"##;
const TODO_SERVICE__UPDATE_TODO_SCHEMA_JSON: &str = r##"{"description":"Updates an existing todo item. Send the todo with its resource name and the fields to update. Use update_mask to specify which fields to modify.","properties":{"todo":{"properties":{"completed":{"description":"Whether the todo is done.","type":"boolean"},"create_time":{"format":"date-time","type":["string","null"]},"description":{"description":"Optional longer description or notes.","type":"string"},"name":{"description":"Resource name (e.g. users/alice/todos/abc123). Required when updating.","type":"string"},"priority":{"description":"Priority level for a todo item.. PRIORITY_UNSPECIFIED: Unspecified; use default priority.. PRIORITY_LOW: Low priority; can be done when convenient.. PRIORITY_MEDIUM: Normal priority; default for most todos.. PRIORITY_HIGH: High priority; should be done soon.. PRIORITY_URGENT: Urgent; do first.","enum":["PRIORITY_UNSPECIFIED","PRIORITY_LOW","PRIORITY_MEDIUM","PRIORITY_HIGH","PRIORITY_URGENT"],"enumDescriptions":{"PRIORITY_HIGH":"High priority; should be done soon.","PRIORITY_LOW":"Low priority; can be done when convenient.","PRIORITY_MEDIUM":"Normal priority; default for most todos.","PRIORITY_UNSPECIFIED":"Unspecified; use default priority.","PRIORITY_URGENT":"Urgent; do first."},"type":"string"},"title":{"description":"Short title for the todo.","type":"string"},"update_time":{"format":"date-time","type":["string","null"]}},"required":[],"type":"object"},"update_mask":{"description":"Comma-separated field names to update (e.g. title,completed). Omit to update all provided fields.","type":"string"}},"required":["todo"],"type":"object"}"##;

#[async_trait]
pub trait TodoServiceMcpServer: Send + Sync + 'static {
    async fn create_todo(&self, args: Value) -> Result<Value, McpError>;
    async fn delete_todo(&self, args: Value) -> Result<Value, McpError>;
    async fn get_todo(&self, args: Value) -> Result<Value, McpError>;
    async fn list_todos(&self, args: Value) -> Result<Value, McpError>;
    async fn update_todo(&self, args: Value) -> Result<Value, McpError>;
}

pub struct TodoServiceMcpHandler<T: TodoServiceMcpServer> { inner: Arc<T> }

impl<T: TodoServiceMcpServer> Clone for TodoServiceMcpHandler<T> {
    fn clone(&self) -> Self { Self { inner: Arc::clone(&self.inner) } }
}

impl<T: TodoServiceMcpServer> TodoServiceMcpHandler<T> {
    pub fn new(svc: T) -> Self { Self { inner: Arc::new(svc) } }

    fn tools() -> Vec<Tool> {
        vec![
            make_tool("todo_service-create_todo_v1", "Creates a new todo item under a user. Requires parent (e.g. users/alice), a todo object with title/description/priority, and a unique todo_id.", TODO_SERVICE__CREATE_TODO_SCHEMA_JSON),
            make_tool("todo_service-delete_todo_v1", "Permanently deletes a todo item by its resource name. This action cannot be undone.", TODO_SERVICE__DELETE_TODO_SCHEMA_JSON),
            make_tool("todo_service-get_todo_v1", "Retrieves a single todo item by its resource name (e.g. users/alice/todos/abc123).", TODO_SERVICE__GET_TODO_SCHEMA_JSON),
            make_tool("todo_service-list_todos_v1", "Lists all todo items for a user. Supports pagination via page_size and page_token.", TODO_SERVICE__LIST_TODOS_SCHEMA_JSON),
            make_tool("todo_service-update_todo_v1", "Updates an existing todo item. Send the todo with its resource name and the fields to update. Use update_mask to specify which fields to modify.", TODO_SERVICE__UPDATE_TODO_SCHEMA_JSON),
        ]
    }

    fn prompts() -> Vec<Prompt> {
        vec![
            serde_json::from_value(json!({
                "name": "summarize_todos",
                "description": "Summarize all pending todo items for a user",
                "arguments": [
                    {"name": "user", "description": "The user ID to summarize todos for.", "required": true},
                ]
            })).expect("generated prompt must be valid"),
            serde_json::from_value(json!({
                "name": "prioritize_todos",
                "description": "Suggest a priority ordering for a user's incomplete todos",
                "arguments": [
                    {"name": "user", "description": "The user ID whose todos to prioritize.", "required": true},
                    {"name": "strategy", "description": "Prioritization strategy.", "required": false},
                ]
            })).expect("generated prompt must be valid"),
        ]
    }

    fn resources() -> Vec<Resource> {
        vec![
        ]
    }

    fn resource_templates() -> Vec<ResourceTemplate> {
        vec![
            serde_json::from_value(json!({
                "uriTemplate": "todo://users/{user}/todos/{todo}", "name": "Todo",
                "description": "Todo resource (users/{user}/todos/{todo})", "mimeType": "application/json"
            })).expect("generated resource template must be valid"),
        ]
    }
}

impl<T: TodoServiceMcpServer> ServerHandler for TodoServiceMcpHandler<T> {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            capabilities: ServerCapabilities::builder()
                .enable_tools()
                .enable_prompts()
                .enable_resources()
                .build(),
            server_info: Implementation { name: "TodoService".into(), version: "0.1.0".into(), ..Default::default() },
            ..Default::default()
        }
    }

    async fn list_tools(&self, _: Option<PaginatedRequestParams>, _: RequestContext<RoleServer>) -> Result<ListToolsResult, McpError> {
        Ok(ListToolsResult::with_all_items(Self::tools()))
    }

    async fn call_tool(&self, request: CallToolRequestParams, context: RequestContext<RoleServer>) -> Result<CallToolResult, McpError> {
        let args = request.arguments.map_or_else(|| Value::Object(Default::default()), Value::Object);
        match request.name.as_ref() {
            "todo_service-create_todo_v1" => {
                if let Ok(schema) = ElicitationSchema::from_json_schema(
                    serde_json::from_value(json!({
                        "type": "object",
                        "properties": {
                            "confirm": {"type": "string", "description": "Confirm creation.", "enum": ["yes", "no", ]},
                        },
                        "required": ["confirm", ]
                    })).unwrap()
                ) {
                    let params = CreateElicitationRequestParams::FormElicitationParams {
                        meta: None,
                        message: "Please confirm the todo details before creating.".to_string(),
                        requested_schema: schema,
                    };
                    match context.peer.create_elicitation(params).await {
                        Ok(result) if result.action != ElicitationAction::Accept => {
                            return Ok(CallToolResult::success(vec![Content::text("Action cancelled by user.")]));
                        }
                        _ => {} // proceed (including errors — graceful degradation)
                    }
                }
                let result = self.inner.create_todo(args).await?;
                let text = serde_json::to_string(&result)
                    .map_err(|e| McpError::internal_error(format!("serialize response: {e}"), None))?;
                Ok(CallToolResult::success(vec![Content::text(text)]))
            }
            "todo_service-delete_todo_v1" => {
                if let Ok(schema) = ElicitationSchema::from_json_schema(
                    serde_json::from_value(json!({
                        "type": "object",
                        "properties": {
                            "confirm": {"type": "string", "description": "Confirm deletion.", "enum": ["yes", "no", ]},
                        },
                        "required": ["confirm", ]
                    })).unwrap()
                ) {
                    let params = CreateElicitationRequestParams::FormElicitationParams {
                        meta: None,
                        message: "Are you sure you want to delete this todo? This action cannot be undone.".to_string(),
                        requested_schema: schema,
                    };
                    match context.peer.create_elicitation(params).await {
                        Ok(result) if result.action != ElicitationAction::Accept => {
                            return Ok(CallToolResult::success(vec![Content::text("Action cancelled by user.")]));
                        }
                        _ => {} // proceed (including errors — graceful degradation)
                    }
                }
                let result = self.inner.delete_todo(args).await?;
                let text = serde_json::to_string(&result)
                    .map_err(|e| McpError::internal_error(format!("serialize response: {e}"), None))?;
                Ok(CallToolResult::success(vec![Content::text(text)]))
            }
            "todo_service-get_todo_v1" => {
                let result = self.inner.get_todo(args).await?;
                let text = serde_json::to_string(&result)
                    .map_err(|e| McpError::internal_error(format!("serialize response: {e}"), None))?;
                Ok(CallToolResult::success(vec![Content::text(text)]))
            }
            "todo_service-list_todos_v1" => {
                let result = self.inner.list_todos(args).await?;
                let text = serde_json::to_string(&result)
                    .map_err(|e| McpError::internal_error(format!("serialize response: {e}"), None))?;
                Ok(CallToolResult::success(vec![Content::text(text)]))
            }
            "todo_service-update_todo_v1" => {
                if let Ok(schema) = ElicitationSchema::from_json_schema(
                    serde_json::from_value(json!({
                        "type": "object",
                        "properties": {
                            "confirm": {"type": "string", "description": "Confirm update.", "enum": ["yes", "no", ]},
                        },
                        "required": ["confirm", ]
                    })).unwrap()
                ) {
                    let params = CreateElicitationRequestParams::FormElicitationParams {
                        meta: None,
                        message: "Please confirm the changes to this todo item.".to_string(),
                        requested_schema: schema,
                    };
                    match context.peer.create_elicitation(params).await {
                        Ok(result) if result.action != ElicitationAction::Accept => {
                            return Ok(CallToolResult::success(vec![Content::text("Action cancelled by user.")]));
                        }
                        _ => {} // proceed (including errors — graceful degradation)
                    }
                }
                let result = self.inner.update_todo(args).await?;
                let text = serde_json::to_string(&result)
                    .map_err(|e| McpError::internal_error(format!("serialize response: {e}"), None))?;
                Ok(CallToolResult::success(vec![Content::text(text)]))
            }
            _ => Err(McpError::internal_error(format!("unknown tool: {}", request.name), None)),
        }
    }

    async fn list_prompts(&self, _: Option<PaginatedRequestParams>, _: RequestContext<RoleServer>) -> Result<ListPromptsResult, McpError> {
        Ok(ListPromptsResult::with_all_items(Self::prompts()))
    }

    async fn get_prompt(&self, request: GetPromptRequestParams, _: RequestContext<RoleServer>) -> Result<GetPromptResult, McpError> {
        for p in Self::prompts() {
            if p.name == request.name {
                let arg_str: String = request.arguments.as_ref()
                    .map(|a| a.iter().map(|(k, v)| format!("{k}={v}")).collect::<Vec<_>>().join(", "))
                    .unwrap_or_default();
                let desc = p.description.clone().unwrap_or_default();
                return Ok(GetPromptResult {
                    description: p.description,
                    messages: vec![PromptMessage {
                        role: PromptMessageRole::User,
                        content: PromptMessageContent::text(format!("{desc} ({arg_str})")),
                    }],
                });
            }
        }
        Err(McpError::invalid_params(format!("unknown prompt: {}", request.name), None))
    }

    async fn list_resources(&self, _: Option<PaginatedRequestParams>, _: RequestContext<RoleServer>) -> Result<ListResourcesResult, McpError> {
        Ok(ListResourcesResult::with_all_items(Self::resources()))
    }

    async fn list_resource_templates(&self, _: Option<PaginatedRequestParams>, _: RequestContext<RoleServer>) -> Result<ListResourceTemplatesResult, McpError> {
        Ok(ListResourceTemplatesResult::with_all_items(Self::resource_templates()))
    }

    async fn read_resource(&self, request: ReadResourceRequestParams, _: RequestContext<RoleServer>) -> Result<ReadResourceResult, McpError> {
        Ok(ReadResourceResult {
            contents: vec![ResourceContents::text("{}", request.uri)],
        })
    }
}

pub const TODO_SERVICE_MCP_DEFAULT_BASE_PATH: &str = "/todo/v1/todoservice/mcp";

pub struct TodoServiceMcpTransportConfig {
    pub transport: String,
    pub host: String,
    pub port: u16,
    pub base_path: String,
}

impl Default for TodoServiceMcpTransportConfig {
    fn default() -> Self {
        Self { transport: "streamable-http".into(), host: "0.0.0.0".into(), port: 8080,
               base_path: TODO_SERVICE_MCP_DEFAULT_BASE_PATH.into() }
    }
}

pub async fn serve_todo_service_mcp_stdio<T: TodoServiceMcpServer>(svc: T) -> Result<(), Box<dyn std::error::Error>> {
    let handler = TodoServiceMcpHandler::new(svc);
    handler.serve(rmcp::transport::stdio()).await?.waiting().await?;
    Ok(())
}

pub async fn serve_todo_service_mcp<T: TodoServiceMcpServer>(
    svc: T, config: TodoServiceMcpTransportConfig,
) -> Result<(), Box<dyn std::error::Error>> {
    let handler = TodoServiceMcpHandler::new(svc);
    let transports: Vec<&str> = config.transport.split(',').map(|s| s.trim()).filter(|s| !s.is_empty()).collect();
    let has_stdio = transports.iter().any(|t| *t == "stdio");
    let http_transport = transports.iter().find(|t| **t == "sse" || **t == "streamable-http").copied();

    if let Some(_ht) = http_transport {
        use rmcp::transport::streamable_http_server::{
            StreamableHttpServerConfig, StreamableHttpService, session::local::LocalSessionManager,
        };
        let h = handler.clone();
        let http_config = StreamableHttpServerConfig {
            sse_retry: None,
            ..StreamableHttpServerConfig::default()
        };
        let http_service = StreamableHttpService::new(
            move || Ok(h.clone()), Arc::new(LocalSessionManager::default()),
            http_config,
        );
        let app = axum::Router::new().nest_service(&config.base_path, http_service);
        let addr = format!("{}:{}", config.host, config.port);
        let listener = tokio::net::TcpListener::bind(&addr).await?;
        if has_stdio {
            tokio::spawn(async move { axum::serve(listener, app).await.expect("HTTP server failed"); });
        } else {
            axum::serve(listener, app).await?;
            return Ok(());
        }
    }

    if has_stdio {
        handler.serve(rmcp::transport::stdio()).await?.waiting().await?;
    } else if http_transport.is_none() {
        return Err(format!("unsupported transport(s): {}", config.transport).into());
    }
    Ok(())
}
