// Code generated by protoc-gen-mcp. DO NOT EDIT.
// Open Source at Machani Robotics - https://github.com/machanirobotics/protoc-mcp-gen
// source: todo/v1/todo_service.proto

use std::sync::Arc;
use async_trait::async_trait;
use rmcp::{ErrorData as McpError, RoleServer, ServerHandler, ServiceExt, model::*, service::RequestContext};
use serde_json::{self, json, Value};

/// Construct a [`Tool`] descriptor from a tool name, human-readable description,
/// and a raw JSON schema string that defines the expected input parameters.
fn make_tool(name: &str, description: &str, schema_json: &str) -> Tool {
    serde_json::from_value(json!({
        "name": name, "description": description,
        "inputSchema": serde_json::from_str::<Value>(schema_json).unwrap(),
    })).expect("generated tool schema must be valid")
}

/// JSON schemas for each RPC method, used as the inputSchema for MCP tools.
const TODO_SERVICE__CREATE_TODO_SCHEMA_JSON: &str = r##"{"properties":{"parent":{"type":"string"},"todo":{"properties":{"completed":{"type":"boolean"},"create_time":{"format":"date-time","type":["string","null"]},"description":{"type":"string"},"name":{"type":"string"},"priority":{"enum":["PRIORITY_UNSPECIFIED","PRIORITY_LOW","PRIORITY_MEDIUM","PRIORITY_HIGH","PRIORITY_URGENT"],"type":"string"},"title":{"type":"string"},"update_time":{"format":"date-time","type":["string","null"]}},"required":[],"type":"object"},"todo_id":{"type":"string"}},"required":["parent","todo","todo_id"],"type":"object"}"##;
const TODO_SERVICE__DELETE_TODO_SCHEMA_JSON: &str = r##"{"properties":{"name":{"type":"string"}},"required":["name"],"type":"object"}"##;
const TODO_SERVICE__GET_TODO_SCHEMA_JSON: &str = r##"{"properties":{"name":{"type":"string"}},"required":["name"],"type":"object"}"##;
const TODO_SERVICE__LIST_TODOS_SCHEMA_JSON: &str = r##"{"properties":{"page_size":{"type":"integer"},"page_token":{"type":"string"},"parent":{"type":"string"}},"required":["parent"],"type":"object"}"##;
const TODO_SERVICE__UPDATE_TODO_SCHEMA_JSON: &str = r##"{"properties":{"todo":{"properties":{"completed":{"type":"boolean"},"create_time":{"format":"date-time","type":["string","null"]},"description":{"type":"string"},"name":{"type":"string"},"priority":{"enum":["PRIORITY_UNSPECIFIED","PRIORITY_LOW","PRIORITY_MEDIUM","PRIORITY_HIGH","PRIORITY_URGENT"],"type":"string"},"title":{"type":"string"},"update_time":{"format":"date-time","type":["string","null"]}},"required":[],"type":"object"},"update_mask":{"type":"string"}},"required":["todo"],"type":"object"}"##;

/// Trait that users implement to handle MCP tool calls backed by TodoService RPCs.
/// Each method receives a JSON [`Value`] containing the request fields and returns
/// a JSON [`Value`] of the response, or an [`McpError`] on failure.
#[async_trait]
pub trait TodoServiceMcpServer: Send + Sync + 'static {
    async fn create_todo(&self, args: Value) -> Result<Value, McpError>;
    async fn delete_todo(&self, args: Value) -> Result<Value, McpError>;
    async fn get_todo(&self, args: Value) -> Result<Value, McpError>;
    async fn list_todos(&self, args: Value) -> Result<Value, McpError>;
    async fn update_todo(&self, args: Value) -> Result<Value, McpError>;
}

/// Wrapper that adapts a [`TodoServiceMcpServer`] implementation into an
/// [`rmcp::ServerHandler`], making it serveable over any MCP transport
/// (stdio, SSE, or streamable-HTTP).
pub struct TodoServiceMcpHandler<T: TodoServiceMcpServer> { inner: Arc<T> }

impl<T: TodoServiceMcpServer> Clone for TodoServiceMcpHandler<T> {
    fn clone(&self) -> Self { Self { inner: Arc::clone(&self.inner) } }
}

impl<T: TodoServiceMcpServer> TodoServiceMcpHandler<T> {
    /// Wrap the service implementation in an [`Arc`] and return a cloneable handler.
    pub fn new(svc: T) -> Self { Self { inner: Arc::new(svc) } }

    /// Build the list of MCP [`Tool`] descriptors from the embedded JSON schemas.
    fn tools() -> Vec<Tool> {
        vec![
            make_tool("todo_v1_TodoService_CreateTodo", "Creates a new todo item.", TODO_SERVICE__CREATE_TODO_SCHEMA_JSON),
            make_tool("todo_v1_TodoService_DeleteTodo", "Deletes a todo item by resource name.", TODO_SERVICE__DELETE_TODO_SCHEMA_JSON),
            make_tool("todo_v1_TodoService_GetTodo", "Retrieves a todo item by resource name.", TODO_SERVICE__GET_TODO_SCHEMA_JSON),
            make_tool("todo_v1_TodoService_ListTodos", "Lists todo items with optional filtering.", TODO_SERVICE__LIST_TODOS_SCHEMA_JSON),
            make_tool("todo_v1_TodoService_UpdateTodo", "Updates an existing todo item.", TODO_SERVICE__UPDATE_TODO_SCHEMA_JSON),
        ]
    }
}

/// [`ServerHandler`] implementation that bridges MCP `list_tools` and `call_tool`
/// requests to the corresponding methods on the user's [`TodoServiceMcpServer`] impl.
impl<T: TodoServiceMcpServer> ServerHandler for TodoServiceMcpHandler<T> {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            capabilities: ServerCapabilities::builder().enable_tools().build(),
            server_info: Implementation { name: "TodoService".into(), version: "0.1.0".into(), ..Default::default() },
            ..Default::default()
        }
    }

    async fn list_tools(&self, _: Option<PaginatedRequestParams>, _: RequestContext<RoleServer>) -> Result<ListToolsResult, McpError> {
        Ok(ListToolsResult { tools: Self::tools(), next_cursor: None, ..Default::default() })
    }

    async fn call_tool(&self, request: CallToolRequestParams, _: RequestContext<RoleServer>) -> Result<CallToolResult, McpError> {
        let args = request.arguments.map_or_else(|| Value::Object(Default::default()), Value::Object);
        match request.name.as_ref() {
            "todo_v1_TodoService_CreateTodo" => {
                let result = self.inner.create_todo(args).await?;
                let text = serde_json::to_string(&result)
                    .map_err(|e| McpError::internal_error(format!("serialize response: {e}"), None))?;
                Ok(CallToolResult::success(vec![Content::text(text)]))
            }
            "todo_v1_TodoService_DeleteTodo" => {
                let result = self.inner.delete_todo(args).await?;
                let text = serde_json::to_string(&result)
                    .map_err(|e| McpError::internal_error(format!("serialize response: {e}"), None))?;
                Ok(CallToolResult::success(vec![Content::text(text)]))
            }
            "todo_v1_TodoService_GetTodo" => {
                let result = self.inner.get_todo(args).await?;
                let text = serde_json::to_string(&result)
                    .map_err(|e| McpError::internal_error(format!("serialize response: {e}"), None))?;
                Ok(CallToolResult::success(vec![Content::text(text)]))
            }
            "todo_v1_TodoService_ListTodos" => {
                let result = self.inner.list_todos(args).await?;
                let text = serde_json::to_string(&result)
                    .map_err(|e| McpError::internal_error(format!("serialize response: {e}"), None))?;
                Ok(CallToolResult::success(vec![Content::text(text)]))
            }
            "todo_v1_TodoService_UpdateTodo" => {
                let result = self.inner.update_todo(args).await?;
                let text = serde_json::to_string(&result)
                    .map_err(|e| McpError::internal_error(format!("serialize response: {e}"), None))?;
                Ok(CallToolResult::success(vec![Content::text(text)]))
            }
            _ => Err(McpError::internal_error(format!("unknown tool: {}", request.name), None)),
        }
    }
}

/// Default HTTP base path for TodoService MCP endpoints.
pub const TODO_SERVICE_MCP_DEFAULT_BASE_PATH: &str = "/todo/v1/todoservice/mcp";

/// Transport configuration for [`serve_todo_service_mcp`].
pub struct TodoServiceMcpTransportConfig {
    /// `"stdio"`, `"sse"`, or `"streamable-http"` (default: `"streamable-http"`).
    pub transport: String,
    /// Bind address for HTTP transports (default: `"0.0.0.0"`).
    pub host: String,
    /// Port for HTTP transports (default: `8080`).
    pub port: u16,
    /// HTTP path prefix (default: [`TODO_SERVICE_MCP_DEFAULT_BASE_PATH`]).
    pub base_path: String,
}

impl Default for TodoServiceMcpTransportConfig {
    fn default() -> Self {
        Self { transport: "streamable-http".into(), host: "0.0.0.0".into(), port: 8080,
               base_path: TODO_SERVICE_MCP_DEFAULT_BASE_PATH.into() }
    }
}

/// Convenience wrapper that serves TodoService MCP over stdio.
/// Blocks until the stdio transport is closed.
pub async fn serve_todo_service_mcp_stdio<T: TodoServiceMcpServer>(svc: T) -> Result<(), Box<dyn std::error::Error>> {
    let handler = TodoServiceMcpHandler::new(svc);
    handler.serve(rmcp::transport::stdio()).await?.waiting().await?;
    Ok(())
}

/// Serve TodoService MCP using the transport(s) specified in `config`.
///
/// The `transport` field accepts comma-separated values to run multiple transports
/// concurrently, e.g. `"stdio,streamable-http"`. HTTP-based transports run in a
/// background tokio task while stdio blocks the current task.
pub async fn serve_todo_service_mcp<T: TodoServiceMcpServer>(
    svc: T, config: TodoServiceMcpTransportConfig,
) -> Result<(), Box<dyn std::error::Error>> {
    let handler = TodoServiceMcpHandler::new(svc);
    let transports: Vec<&str> = config.transport.split(',').map(|s| s.trim()).filter(|s| !s.is_empty()).collect();
    let has_stdio = transports.iter().any(|t| *t == "stdio");
    let http_transport = transports.iter().find(|t| **t == "sse" || **t == "streamable-http").copied();

    if let Some(_ht) = http_transport {
        use rmcp::transport::streamable_http_server::{
            StreamableHttpServerConfig, StreamableHttpService, session::local::LocalSessionManager,
        };
        let h = handler.clone();
        let http_config = StreamableHttpServerConfig {
            sse_retry: None,
            ..StreamableHttpServerConfig::default()
        };
        let http_service = StreamableHttpService::new(
            move || Ok(h.clone()), Arc::new(LocalSessionManager::default()),
            http_config,
        );
        let app = axum::Router::new().nest_service(&config.base_path, http_service);
        let addr = format!("{}:{}", config.host, config.port);
        let listener = tokio::net::TcpListener::bind(&addr).await?;
        if has_stdio {
            tokio::spawn(async move { axum::serve(listener, app).await.expect("HTTP server failed"); });
        } else {
            axum::serve(listener, app).await?;
            return Ok(());
        }
    }

    if has_stdio {
        handler.serve(rmcp::transport::stdio()).await?.waiting().await?;
    } else if http_transport.is_none() {
        return Err(format!("unsupported transport(s): {}", config.transport).into());
    }
    Ok(())
}
